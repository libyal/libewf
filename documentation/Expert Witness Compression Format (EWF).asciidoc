= EWF specification
Expert Witness Compression Format specification

:toc:
:toclevels: 4

:numbered!:
[abstract]
== Summary
EWF is short for Expert Witness Compression Format, according to `[ASR02]`. It is 
a file type used to store media images for forensic purposes. It is currently 
widely used in the field of computer forensics in proprietary tooling like 
EnCase en FTK. The original specification of the format is provided by ASRDATA, 
for the SMART application.

The EWF format was succeeded by the Expert Witness Compression Format version 2 
in EnCase 7 (EWF2-Ex01 and EWF2-Lx01). EnCase 7 also uses a different version 
of EWF-L01 then its predecessors.

This document is intended as a working document for the EWF specification. 
Which should allow existing Open Source forensic tooling to be able to process 
this file type.

[preface]
== Document information
[cols="1,5"]
|===
| Author(s): | Joachim Metz <joachim.metz@gmail.com>
| Abstract: | This document contains the EWF file format specification.
| Classification: | Public
| Keywords: | Expert Witness Compression Format, EWF, EnCase file format, SMART
|===

[preface]
== License
....
Copyright (C) 2006-2016, Joachim Metz <joachim.metz@gmail.com>.
Permission is granted to copy, distribute and/or modify this document under the 
terms of the GNU Free Documentation License, Version 1.3 or any later version 
published by the Free Software Foundation; with no Invariant Sections, no 
Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included 
in the section entitled "GNU Free Documentation License".
....

[preface]
== Revision history
[cols="1,1,1,5",options="header"]
|===
| Version | Author | Date | Comments
| 0.0.1 | J.B. Metz | March 2006 | Initial version
| 0.0.2 | J.B. Metz | March 2006 | Additional information.
| 0.0.3 | J.B. Metz | March 2006 | Additional information.
| 0.0.4 | J.B. Metz | March 2006 | Additional information.
| 0.0.5 | J.B. Metz | March 2006 | Additional information, regarding data and header2 section.
| 0.0.6 | J.B. Metz | March 2006 | Additional information, regarding data and header2 section.
| 0.0.7 | J.B. Metz | March 2006 | Additional information, regarding data, hash and header2 section.
| 0.0.8 | J.B. Metz | March 2006 | Additional information, regarding data section.
| 0.0.9 | J.B. Metz | March 2006 | Additional information, regarding chunk and compression, offset array CRC and error2 section.
| 0.0.10 | J.B. Metz | March 2006 | Correction regarding EnCase 3 and compression MSB.
| 0.0.11 | J.B. Metz | March 2006 | Additions regarding EnCase 2.
| 0.0.12 | J.B. Metz | March 2006 | Small changes regarding unknown in volume and data. Removed some spelling errors. Added the information regarding when a chunk is compressed or not.
| 0.0.13 | J.B. Metz | April 2006 | Additions regarding EnCase 1.
| 0.0.14 | J.B. Metz | April 2006 | Additions regarding byte order.
| 0.0.15 | J.B. Metz | April 2006 | Additions regarding disk section.
| 0.0.16 | J.B. Metz | April 2006 | Small adjustments regarding header section.
| 0.0.17 | J.B. Metz | April 2006 | Adjustments in error2 section information.
| 0.0.18 | J.B. Metz | May 2006 | Adjustments in hash section information.
| 0.0.19 | J.B. Metz | August 2006 | Fixed error in EnCase 4 header2 layout information.
| 0.0.20 | J.B. Metz | August 2006 | Added information regarding SMART format generated by FTK Imager. Corrected error about gzip compression in header section.
| 0.0.21 | J.B. Metz | August 2006 | Added information regarding SMART format generated by FTK Imager.
| 0.0.22 | J.B. Metz | August 2006 | Added information about segment file extension naming.
| 0.0.23 | J.B. Metz | September 2006 | Added information about EWF-L01 (LVF) format.
| 0.0.24 | J.B. Metz | September 2006 | Added information from EWF-L01 analysis.
| 0.0.25 | J.B. Metz | September 2006 | Changes after comments by Guy Voncken.
| 0.0.26 | J.B. Metz | October 2006 | Corrected error regarding EnCase 1 and SMART header specification.
| 0.0.27 | J.B. Metz | October 2006 | Added theoretical maximum media size.
| 0.0.28 | J.B. Metz | October 2006 | Additional information about section start size in EnCase (EWF-E01) next and done sections.
| 0.0.29 | J.B. Metz | November 2006 | Additional information about CRC algorithm.
| 0.0.30 | J.B. Metz | November 2006 | Fixed error regarding the location of the actual chunks in the EnCase 1 format, which actually is the table sections and not the sectors section.
| 0.0.31 | J.B. Metz | November 2006 | Additional information about the EnCase linen 5 (EWF-E01) format.
| 0.0.32 | J.B. Metz | December 2006 | Additional information about GUID.
| 0.0.33 | J.B. Metz | December 2006 | Corrected error regarding header sections in EnCase 1 format.
| 0.0.34 | J.B. Metz | December 2006 | Added new information regarding the table section after encountering a bug in FTK for EWF files with more than 16 x 1024 offset table entries.
| 0.0.35 | J.B. Metz | December 2006 | Corrected misinterpretation of original specifications, regarding additional table sections.
| 0.0.36 | J.B. Metz | January 2007 | Added information about EnCase 6.
| 0.0.37 | J.B. Metz | January 2007 | Added information about linen 6.
| 0.0.38 | J.B. Metz | January 2007 | Added information about EnCase6/linen6 header. +
Adjustments regarding media type and media flags.
| 0.0.39 | J.B. Metz | January 2007 | Added information about header values.
| 0.0.40 | J.B. Metz | January 2007 | Added information about EWF-X
| 0.0.41 | J.B. Metz | August 2007 | Added information about EnCase 6.7 >2Gb segment file support.
| 0.0.42 | J.B. Metz | August 2007 | Added information about EnCase 6.7 >2Gb segment file support and CD/DVD image session sector.
| 0.0.43 | J.B. Metz | September 2007 | Added information about EnCase 6.7 >2Gb segment file support.
| 0.0.44 | J.B. Metz | September 2007 | Added page numbers.
| 0.0.45 | J.B. Metz | November 2007 | Added information about session section.
| 0.0.46 | J.B. Metz | March 2008 | Added information about session section.
| 0.0.47 | J.B. Metz | March 2008 | Added information about EnCase 6 >2GiB segment file format.
| 0.0.48 | J.B. Metz | June 2008 | Textual corrections.
| 0.0.49 | J.B. Metz | June 2008 | Added information about EnCase 6.11 winen file format.
| 0.0.50 | J.B. Metz | February 2009 | Added information about EnCase 6.12 SHA1 hash support and header values.
| 0.0.51 | J.B. Metz | April 2009 | Added information about EnCase software version header value limitation.
| 0.0.52 | J.B. Metz | April 2009 | Added information about EnCase 6.13 Tableau write blocker support.
| 0.0.53 | J.B. Metz | November 2009 | Small changes.
| 0.0.54 | J.B. Metz | December 2009 +
January 2010 | Added information about ltree section.
| 0.0.55 | J.B. Metz | January 2010 | Update for linen 6.12 and later.
| 0.0.56 | J.B. Metz | May 2010 | Corrected amount of into number of. +
Email change
| 0.0.57 | J.B. Metz | September 2010 | Minor changes.
| 0.0.58 | J.B. Metz | September 2010 | Changed CRC to checksum.
| 0.0.59 | J.B. Metz | October 2010 | Additional session section information with thanks to M. Nohr +
Updated some tables to the newer format. +
Minor changes.
| 0.0.60 | J.B. Metz | November 2010 | Minor changes and improvements with thanks to G. Voncken. +
Updated some tables to the newer format.
| 0.0.61 | J.B. Metz | December 2010 | License version update +
Additional information about optical discs. +
Additional information about AD encryption.
| 0.0.62 | J.B. Metz | January 2011 | Minor changes
| 0.0.63 | J.B. Metz | February 2011 | Additional audio tracks information with thanks to M. Nohr
| 0.0.64 | J.B. Metz | May 2011 | Changes to FTK imager format
| 0.0.65 | J.B. Metz | June 2011 | Updated Logical File Evidence (LVF) format flag information with thanks to B. Baron.
| 0.0.66 | J.B. Metz | September 2011 | Updated Logical File Evidence (LVF) format flag information with thanks to N. Harris
| 0.0.67 | J.B. Metz | December 2011 | Small refinement in compressed vs uncompressed chunk data.
| 0.0.68 | J.B. Metz | February 2012 | Added information about EnCase header values limitations thanks to G. Voncken.
| 0.0.69 | J.B. Metz | June 2012 | Added information about EnCase 6.19 and 7, EWF-E01 and EWF-L01 format. Email change; text clean up; some corrections and additions.
| 0.0.70 | J.B. Metz | July 2012 | Changes to match EWF version 2 documentation.
| 0.0.71 | J.B. Metz | July 2012 | Updates regarding ltree header.
| 0.0.72 | J.B. Metz | July 2012 | Updates files created by Expert Witness 1.35 (for Windows). +
Other small corrections.
| 0.0.73 | J.B. Metz | August 2012 | Updates regarding ltree header.
| 0.0.74 | J.B. Metz | August 2012 | Updates regarding incomplete section and corruption scenarios with thanks to B. Johnson for pointing out the dual image scenario.
| 0.0.75 | J.B. Metz | September 2012 | Additional information regarding L01 map entry.
| 0.0.76 | J.B. Metz | January 2013 | Corrected some typos, thanks to A. Bridge for pointing these out.
| 0.0.77 | J.B. Metz | March 2013 | Additional information regarding Logicube created E01 files with thanks to D. Kovar and Digital Assembly LLC.
| 0.0.78 | J.B. Metz | March 2013 | Improved description of zlib compressed data format (RFC1950) and deflate compression (RFC1951). +
Updated the information regarding Logicube products and the data section checksum behavior.
| 0.0.79 | J.B. Metz | August 2015 | Switched to asciidoc format.
| 0.0.80 | J.B. Metz | April 2016 | Updates regarding ltree.
| 0.0.81 | Z. Travis | May 2017 | Details of AD encryption
|===

:numbered:
== Overview
The Expert Witness Compression Format (EWF) is used to store media images. It 
allows to store disk and partition images, compressed or non-compressed. EWF 
can store a single image in one or more segment files. Each segment file 
consist of a standard header, followed by multiple sections. A single section 
cannot span multiple files. Sections are arranged back-to-back.

Specifications:

* In this document when referred to the EWF format it refers to the original specification by `[ASR02]`. The newer formats like that of EnCase are deducted from the original specification and will be referred to as the EWF-E01, because of the default file extension. Whereas the Logical File Evidence (LVF) format introduced in EnCase 5, which is also stored in the EWF format will be referred to as EWF-L01. The SMART format is viewed separately to allow for discussion if the implementation differs from the specification by `[ASR02]` and will be referred to as the EWF-S01, because of the default file extension.
* All offsets are relative to the beginning of an individual section, unless otherwise noted. EnCase allows a maximum size of a segment file to be 2000 MiB. This has to do with the size of the offset of the chunk of media data. This is a 32 bit value where the most significant bit (MSB) is used as a compression flag. Therefore the maximum offset size (31 bit) can address about 2048 MiB. In EnCase 6.7 an addition was made to the table value to provide for a base offset to allow for segment files greater than 2048 MiB.
* A chunk is defined as the sector size (per default 512 bytes) multiplied by the block size, the number of sectors per chunk (block) (per default 64 sectors). The data within the EWF format is stored in little-endian. The terms block and chunk are used intermittently.

=== Test version
The following version of programs were used to test the information within this document:

* FTK Imager 2.3, 2.4, 2.51, 2.9, 3.0 (Windows)
* Expert Witness 1.35 (for Windows) (EnCase 1.35)
* EnCase 1.99l (Windows)
* EnCase 2.17a (DOS)
* EnCase 3.21b (Windows)
* EnCase 4.22 (Windows)
* EnCase 5.04a, 5.05 (Windows)
* EnCase 6.1, 6.7, 6.8, 6.10, 6.11, 6.12, 6.13, 6.14, 6.19 (Windows)
* EnCase 7.04 (Windows)
* Linen 5 (Linux)
* Linen 6.01, 6.19 (Linux)
* Linen 7.01 (Linux)

EnCase 7 no longer provides the fast and best compression options.

== Segment file
EWF stores data in one or more segment files (or segments). Each segment file 
consists of:

* A file header.
* One or more sections.

=== File header
Each segment file starts with a file header.

`[ASR02]` defines that the file header consists of 2 parts, namely:

* a signature part
* fields part

==== EWF, EWF-E01 and EWF-S01
This is file header is defined by `[ASR02]` and both used by the EWF-E01 and 
EWF-S01 formats.

The file header is 13 bytes of size and consists 

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 8 | | Signature +
"EVF\x09\x0d\x0a\xff\x00" 
| 8 | 1 | 0x01 | Start of fields
| 9 | 2 | | Segment number +
Must be 1 or higher
| 11 | 2 | 0x0000 | End of fields
|===

Segment number contains a number which refers to the number of the segment 
file, starting with 1 for the first file.

[NOTE]
This means there could only be a maximum of 65535 (0xffff) files, if it is an 
unsigned value.

==== EWF-L01
This is file header is used by the EWF-L01 format.

The file header is 13 bytes of size and consists 

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 8 | | Signature +
"LVF\x09\x0d\x0a\xff\x00" 
| 8 | 1 | 0x01 | Start of fields
| 9 | 2 | | Segment number +
Must be 1 or higher
| 11 | 2 | 0x0000 | End of fields
|===

Segment number contains a number which refers to the number of the segment 
file, starting with 1 for the first file.

[NOTE]
This means there could only be a maximum of 65535 (0xffff) files, if it is an 
unsigned value.

=== Segment file extensions
Both the SMART (EWF-S01) and the EWF-E01 use a different approach for naming 
the segment files.

==== EWF-S01
The EWF-S01 extension naming has two distinct parts.

* The first segment file has the extension '.s01'.
** The next segment file has the extension '.s02.
** This will continue up to '.s99'.
* After which the next segment file has the extension '.saa'.
** The next segment file has the extension '.sab'.
** This will continue up to '.saz'.
** The next segment file has the extension '.sba'.
** This will continue up to '.szz'.
** The next segment file has the extension '.faa'.
** This will continue up to '.zzz'. ([yellow-background]*verify this; and then ?*)
** [yellow-background]*It will even continue to the use the extensions '.{aa'. (not confirmed)*

libewf supports extensions up to .zzz

==== EWF-E01
The EWF-E01 extension naming has two distinct parts.

* The first segment file has the extension '.E01'.
** The next segment file has the extension '.E02.
** This will continue up to '.E99'.
* After which the next segment file has the extension '.EAA'.
** The next segment file has the extension '.EAB'.
** This will continue up to '.EAZ'.
** The next segment file has the extension '.EBA'.
** This will continue up to '.EZZ'.
** The next segment file has the extension '.FAA'.
** This will continue up to '.ZZZ'. ([yellow-background]*verify this; and then ?*)
** [yellow-background]*It will even continue to the use the extensions '.[AA'. (not confirmed)*

libewf supports extensions up to .ZZZ

==== EWF-L01
The EWF-L01 extension naming has two distinct parts.

* The first segment file has the extension '.L01'.
** The next segment file has the extension '.L02.
** This will continue up to '.L99'.
* After which the next segment file has the extension '.LAA'.
** The next segment file has the extension '.LAB'.
** This will continue up to '.LAZ'.
** The next segment file has the extension '.LBA'.
** This will continue up to '.LZZ'.
** The next segment file has the extension '.MAA'.
** This will continue up to '.ZZZ'. ([yellow-background]*verify this; and then ?*)
** [yellow-background]*It will even continue to the use the extensions '.[AA'. (not confirmed)*

libewf supports extensions up to .ZZZ

=== Segment file set identifier GUID
Segment file sets do not have a strict unique identifier. However the 
<<volume_section,volume section>> contains a GUID that can be used for this 
purpose. Where:

* linen 5 to 6 use a time and MAC address based version (1) of the GUID
* EnCase 5 to 7 and linen 6 to 7 use a random based version (4) of the GUID

[yellow-background]*In linen 6 the switch from a version 1 to 4 GUID was 
somewhere made between version 6.01 and 6.19.*

See RFC4122 for more information about the different GUID versions.

== The sections
The remainder of the segment file consists of sections. Every section starts 
with the same data this will be referred to as the section descriptor 
(previously referred to as section start). The section descriptor could also be 
referred as the section header, but this allows for unnecessary confusion with 
the header section.

=== Section descriptor
The section descriptor consist of 76 bytes, it contains information about a 
specific section.

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 16 | | A string containing the section type definition. +
E.g. "header", "volume", etc.
| 16 | 8 | | Next section offset +
The offset is relative from the start of the segment file
| 24 | 8 | | Section size
| 32 | 40 | 0x00 | Padding
| 72 | 4 | | Checksum +
Adler-32 of all the previous data within the section descriptor.
|===

Some sections contain additional data, refer to paragraph section types for 
more information.

[NOTE]
In EnCase 2 DOS version the padding itself does not contains zero byte values 
but data, probably the memory is not wiped.

[NOTE]
Expert Witness 1.35 (for Windows) does not set the section size.

=== Section types
There are multiple section types. `[ASR02]` defines the following:

* Header section
* Volume section
* Table section
* Next and Done section

Looking at more recent EnCase file (EWF-E01) formats and `[COH]` additional 
section types were found:

* Header2 section
* Disk section
* Sectors section
* Table2 section
* Data section
* Errors2 section
* Session section
* Hash section
* Digest section

Looking at the more recent EnCase file (EWF-L01) format additional section 
types were found:

* Ltree section
* Ltypes section

=== Header2 section
The header2 section is identified in the section data type field as "header2". 
Some aspects of this section are:

* Found in EWF-E01 in EnCase 4 to 7, and EWF-L01 in EnCase 5 to 7
* Found at the start of the first segment file. Not found in other segment files.
* The same header2 section is found twice directly after one and other.

The additional data this section contains is the following:

[cols="1,1,5",options="header"]
|===
| Offset | Number of bytes | Description
| 76 (0x4c) | (variable) | Information about the acquired media.
|===

The information about the acquired media consists of zlib compressed data (see 
section: <<compression,Compression>>). It contains text in UTF16 format 
specifying information about the acquired media. The text multiple lines 
separated by an end of line character(s).

The first 2 bytes of the UTF16 string are the byte order mark (BOM):

* 0xff 0xfe for UTF-16 litte-endian
* 0xfe 0xff for UTF-16 big-endian

In the next paragraphs the various variants of the header2 section are described.

==== EnCase 4 (EWF-E01)
In EnCase 4 (EWF-E01) the header2 information consist of 5 lines, and contains 
the equivalent information as the header section.

[cols="1,1,5",options="header"]
|===
| Line number | Value | Description
| 1 | 1 | The number of categories provided
| 2 | main | The name/type of the category provided
| 3 | | Identifiers for the values in the 4th line
| 4 | | The data for the different identifiers in the 3rd line
| 5 | | (an empty line)
|===

The end of line character(s) is a newline (0x0a).

[NOTE]
This end of line character differs from the one used in the header section.

The 3rd and the 4th line consist of the following tab (0x09) separated values.

[cols="1,1,5",options="header"]
|===
| Identifier number | Character in 3rd line | Value in 4th line
| 1 | a | Unique description
| 2 | c | Case number
| 3 | n | Evidence number
| 4 | e | Examiner name
| 5 | t | Notes
| 6 | av | Version +
The EnCase version used to acquire the media
| 7 | ov | Platform +
The platform/operating system used to acquire the media
| 8 | m | Acquired date
| 9 | u | System date
| 10 | p | Password hash
|===

For more information see section: <<header2_values,Header2 values>>

[NOTE]
The hashing algorithm is the same as for the header section.

==== EnCase 5 to 7 (EWF-E01)
In EnCase 5 to 7 (EWF-E01) the header2 information consist of 17 lines, and 
contains:

[cols="1,1,5",options="header"]
|===
| Line number | Value | Description
| 1 | 3 | The number of categories provided
| 2 | main | The name/type of the category provided
| 3 | | Identifier for the values in the category
| 4 | | The data for the different identifiers in the category
| 5 | | (an empty line)
| 6 | srce | The name/type of the category provided
| 7 | | 
| 8 | | Identifier for the values in the category
| 9 | | The data for the different identifiers in the category
| 10 | | 
| 11 | | (an empty line)
| 12 | sub | The name/type of the category provided
| 13 | | 
| 14 | | Identifier for the values in the category
| 15 | | The data for the different identifiers in the category
| 16 | | 
| 17 | | (an empty line)
|===

The end of line character(s) is a newline (0x0a).

===== Main category
The 3rd and the 4th line consist of the following tab (0x09) separated values.

[NOTE]
The actual values in this category are dependent on the version of EnCase.

[cols="1,1,5",options="header"]
|===
| Identifier number | Character in 3rd line | Value in 4th line
| 1 | a | Unique description
| 2 | c | Case number
| 3 | n | Evidence number
| 4 | e | Examiner name
| 5 | t | Notes
| 6 | md | The model of the media, i.e. hard disk model +
(introduced in EnCase 6)
| 7 | sn | The serial number of media +
(introduced in EnCase 6)
| 8 | l | The device label +
(introduced in EnCase 6.19)
| 9 | av | Version +
The EnCase version used to acquire the media +
EnCase limits this value to 12 characters
| 10 | ov | Platform +
The platform/operating system used to acquire the media
| 11 | m | Acquired date
| 12 | u | System date
| 13 | p | Password hash
| 14 | pid | Process identifier +
The identifier of the process memory acquired +
(introduced in EnCase 6.12/Winen 6.11)
| 15 | dc | [yellow-background]*Unknown*
| 16 | ext | Extents +
The extents of the process memory acquired +
(introduced in EnCase 6.12/Winen 6.11)
|===

For more information see section: <<header2_values,Header2 values>>

====== Notes
Both the acquiry and system date are empty in a file created by winen. 

The date values in the header section (not header2) are set to: Thu Jan  1 
00:00:00 1970. Where the time is dependent on the time zone and daylight 
savings.

===== Sources category
Line 6 the srce category contains information about sources.

[yellow-background]*TODO describe what a source is in the context of EnCase.*

Line 7 consists of 2 values, namely the values are "0 1".

The 8th line consist of the following tab (0x09) separated values. Note that 
the actual values in this category are dependent on the version of EnCase.

[cols="1,1,5",options="header"]
|===
| Identifier number | Character in 8rd line | Meaning
| 1 | p | 
| 2 | n | 
| 3 | id | [yellow-background]*Unknown (Identifier, unique name)*
| 4 | ev | [yellow-background]*Unknown (Evidence number)*
| 5 | tb | [yellow-background]*Unknown (Total bytes)*
| 6 | lo | [yellow-background]*Unknown (Logical offset)*
| 7 | po | [yellow-background]*Unknown (Physical offset)*
| 8 | ah | [yellow-background]*Unknown (Acquire hash)*
| 9 | sh | [yellow-background]*Unknown* +
(introduced in EnCase 6.19)
| 10 | gu | [yellow-background]*Unknown (GUID)*
| 11 | pgu | [yellow-background]*Unknown* +
(introduced in EnCase 7)
| 12 | aq | [yellow-background]*Unknown (Acquire date)*
|===

Line 9 consists of 2 values, namely the values are "0 0".

Line 10 contains the values defined by line 8.

[NOTE]
The default values of some of these values has changed around EnCase 6.12.

===== Subjects category
Line 12 the sub category contains information about subjects.

[yellow-background]*TODO describe what a subject is in the context of EnCase.*

Line 13 consists of 2 values, namely the values are "0 1".

The 14th line consist of the following tab (0x09) separated values.

[cols="1,1,5",options="header"]
|===
| Identifier number | Character in 14rd line | Meaning
| 1 | p | 
| 2 | n | 
| 3 | id | [yellow-background]*Unknown (Identifier, unique name)*
| 4 | nu | [yellow-background]*Unknown (Number)*
| 5 | co | [yellow-background]*Unknown (Comment)*
| 6 | gu | [yellow-background]*Unknown (GUID)*
|===

Line 15 consists of 2 values, namely the values are "0 0".

Line 16 contains the values defined by line 14. Note that the default values of 
some of these values has changed around EnCase 6.12.

==== EnCase 5 to 7 (EWF-L01)
The EnCase 5 to 7 (EWF-E01) header2 section specification also applies to the
EnCase 5 to 7 (EWF-L01) format. However:

* both the acquired date and system date are not set

==== [[header2_values]]Header2 values

[cols="1,1,5",options="header"]
|===
| Identifier | Description | Notes
| a | Unique description | Free form string +
Note that EnCase might not respond when this value is large e.g. >= 1 MiB
| c | Case number | Free form string +
EnCase limits this string to 3000 - 1 characters
| n | Evidence number | Free form string +
EnCase limits this string to 3000 - 1 characters
| e | Examiner name | Free form string +
EnCase limits this string to 3000 - 1 characters
| t | Notes | Free form string +
EnCase limits this string to 3000 - 1 characters
| md | Model | Free form string +
EnCase limits this string to 3000 - 1 characters
| sn | Serial Number | Free form string +
EnCase limits this string to 3000 - 1 characters
| l | Device label | Free form string
| av | Version | Free form string +
EnCase limits this string to 12 - 1 characters
| ov | Platform | Free form string +
EnCase limits this string to 24 - 1 characters
| m | Acquired date | String containing Unix 32-bit epoch timestamp +
E.g. "1142163845" which represents the date: March 12 2006, 11:44:05
| u
| System date | String containing Unix 32-bit epoch timestamp +
E.g. "1142163845" which represents the date: March 12 2006, 11:44:05
| p | Password hash | String containing the password hash. +
If no password is set it should be simply the character '0'. 
| pid | Process identifier | String containing the process identifier (pid) number
| dc | [yellow-background]*Unknown* | 
| ext | Extents | extents contains: +
number of entries +
entries that consist of: S <1> <2> <3>
|===

[NOTE]
The restrictions were tested with EnCase 7.02.01, older versions could have a 
restriction of 40 characters instead of 3000 characters.

=== Header section
The header section is identified in the section data type field as "header". 
Some aspects of this section are:

* It is defined in the EWF format `[ASR02]`.
* Found in EWF-E01 in EnCase 1 to 7 or linen 5 to 7 or FTK Imager, EWF-L01 in EnCase 5 to 7, and SMART (EWF-S01)
* Found at the start of the first segment file or in EnCase 4 to 7 after the header2 section in the first segment file. Not found in other segment files.

The additional data this section contains is the following

[cols="1,1,5",options="header"]
|===
| Offset | Number of bytes | Description
| 76 (0x4c) | (variable) | Information about the acquired media.
|===

The information about the acquired media consists of zlib compressed data (see 
section: <<compression,Compression>>). It contains text in ASCII format 
specifying information about the acquired media. The text multiple lines 
separated by an end of line character(s).

In the next paragraphs the various variants of the header section are 
described. In all cases the information consists of at least 4 lines:

[cols="1,1,5",options="header"]
|===
| Line number | Value | Description
| 1 | 1 | The number of categories provided
| 2 | main | The name/type of the category provided
| 3 | | Identifiers for the values in the 4th line
| 4 | | The data for the different identifiers in the 3rd line
|===

An additional 5th line is found in FTK Imager, EnCase 1 to 7 (EWF-E01).

[cols="1,1,5",options="header"]
|===
| 5 | | (an empty line)
|===

==== EWF format
Some aspects of this section are:

* `[ASR02]` specifies the end of line character(s) is a newline (0x0a).

According to `[ASR02]` the 3rd and the 4th line consist of the following tab 
(0x09) separated values:

[cols="1,1,5",options="header"]
|===
| Identifier number | Character in 3rd line | Value in 4th line
| 1 | c | Case number
| 2 | n | Evidence number
| 3 | a | Unique description
| 4 | e | Examiner name
| 5 | t | Notes
| 6 | m | Acquired date
| 7 | u | System date
| 8 | p | Password hash
| 9 | r | Compression level
|===

For more information see section: <<header_values,Header values>>

`[ASR02]` states that the Expert Witness Compression uses 'f', fastest compression.

==== EnCase 1 (EWF-E01)
Some aspects of this section are:

* The header section is defined only once.
* It is the first section of the first segment file. It is not found in other segment files.
* The header data itself is compressed using zlib.
* The end of line character(s) is a carriage return (0x0d) followed by a newline (0x0a).

The 3rd and the 4th line consist of the following tab (0x09) separated values"

[cols="1,1,5",options="header"]
|===
| Identifier number | Character in 3rd line | Value in 4th line
| 1 | c | Case number
| 2 | n | Evidence number
| 3 | a | Unique description
| 4 | e | Examiner name
| 5 | t | Notes
| 6 | m | Acquired date
| 7 | u | System date
| 8 | p | Password hash
| 9 | r | Compression level
|===

For more information see section: <<header_values,Header values>>

==== SMART (EWF-S01)
Some aspects of this section are:

* The header section is defined once.
* It is the first section of the first segment file. It is not found in other segment files.
* The header data is always processed by zlib, however the same compression level is used as for the chunks. This could mean compression level 0 which is no compression.

The SMART format uses the FTK Imager (EWF-E01) specification for this section. 
[yellow-background]*Note that this could be something FTK Imager specific.*

==== EnCase 2 and 3 (EWF-E01)
Some aspects of this section are:

* The same header section defined twice.
* It is the first and second section of the first segment file. It is not found in other segment files.
* The header data itself is compressed using zlib.
* The end of line character(s) is a carriage return (0x0d) followed by a newline (0x0a).

The 3rd and the 4th line consist of the following tab (0x09) separated values:

[cols="1,1,5",options="header"]
|===
| Identifier number | Character in 3rd line | Value in 4th line
| 1 | c | Case number
| 2 | n | Evidence number
| 3 | a | Unique description
| 4 | e | Examiner name
| 5 | t | Notes
| 6 | av | Version
| 7 | ov | Platform +
The platform/operating system used to acquire the media
| 8 | m | Acquired date
| 9 | u | System date
| 10 | p | Password hash
| 11 | r | Compression level
|===

For more information see section: <<header_values,Header values>>

==== EnCase 4 to 7 (EWF-E01)
Some aspects of this section are:

* The header is defined only once.
* It resides after the header2 sections of the first segment file. It is not found in other segment files.
* The header data itself is compressed using zlib.
* The end of line character(s) is a carriage return (0x0d) followed by a newline (0x0a).

The 3rd and the 4th line consist of the following tab (0x09) separated values:

[cols="1,1,5",options="header"]
|===
| Identifier number | Character in 3rd line | Value in 4th line
| 1 | c | Case number
| 2 | n | Evidence number
| 3 | a | Unique description
| 4 | e | Examiner name
| 5 | t | Notes
| 6 | av | Version
| 7 | ov | Platform +
The platform/operating system used to acquire the media
| 8 | m | Acquired date
| 9 | u | System date
| 10 | p | Password hash
|===

For more information see section: <<header_values,Header values>>

==== linen 5 to 7 (EWF-E01)
Some aspects of this section are:

* The same header section defined twice.
* It is the first and second section of the first segment file. It is not found in other segment files.
* The header data itself is compressed using zlib.
* The end of line character(s) is a newline (0x0a).

The header information consist of 18 lines

The remainder of the string contains the following information:

[cols="1,1,5",options="header"]
|===
| Line number | Value | Description
| 1 | 3 | The number of categories provided
| 2 | main | The name/type of the category provided
| 3 | | Identifier for the values in the 4th line
| 4 | | The data for the different identifiers in the 3rd line
| 5 | | (an empty line)
| 6 | srce | The name/type of the section provided
| 7 | | 
| 8 | | Identifier for the values in the section
| 9 | | 
| 10 | | 
| 11 | | (an empty line)
| 12 | sub | The name/type of the section provided
| 13 | | 
| 14 | | Identifier for the values in the section
| 15 | | 
| 16 | | 
| 17 | | (an empty line)
|===

The end of line character(s) is a newline (0x0a).

===== Main category
The 3rd and the 4th line consist of the following tab (0x09) separated values. 

[NOTE]
The actual values in this category are dependent on the version of linen.

[cols="1,1,5",options="header"]
|===
| Identifier number | Character in 3rd line | Value in 4th line
| 1 | a | Unique description
| 2 | c | Case number
| 3 | n | Evidence number
| 4 | e | Examiner name
| 5 | t | Notes
| 6 | md | The model of the media, i.e. hard disk model +
(Introduced in linen 6)
| 7 | sn | The serial number of media +
(Introduced in linen 6)
| 8 | l | The device label +
(Introduced in linen 6.19)
| 9 | av | Version
| 10 | ov | Platform +
The platform/operating system used to acquire the media
| 11 | m | Acquired date
| 12 | u | System date
| 13 | p | Password hash
| 14 | pid | Process identifier +
The identifier of the process memory acquired +
(Introduced in linen 6.19 or earlier)
| 15 | dc | [yellow-background]*Unknown* +
(Introduced in linen 6)
| 16 | ext | Extents +
The extents of the process memory acquired +
(Introduced in linen 6.19 or earlier)
|===

[NOTE]
As of linen 6.19 the acquire date (and time) is in UTC and the system date is 
in local time. Where as before both date values were in local time.

For more information see section: <<header_values,Header values>>

===== Sources category
Line 6 the srce category contains information about sources

[yellow-background]*TODO describe what a source is in the context of EnCase.*

Line 7 consists of 2 values, namely the values are "0 1".

The 8th line consist of the following tab (0x09) separated values.

[cols="1,1,5",options="header"]
|===
| Identifier number | Character in 8rd line | Meaning
| 1 | p | 
| 2 | n | 
| 3 | id | [yellow-background]*Unknown (Identifier, unique name)*
| 4 | ev | [yellow-background]*Unknown (Evidence number)*
| 5 | tb | [yellow-background]*Unknown (Total bytes)*
| 6 | lo | [yellow-background]*Unknown (Logical offset)*
| 7 | po | [yellow-background]*Unknown (Physical offset)*
| 8 | ah | [yellow-background]*Unknown (Acquire hash)*
| 9 | sh | [yellow-background]*Unknown* +
(Introduced in linen 6.19 or earlier)
| 10 | gu | [yellow-background]*Unknown (GUID)*
| 11 | aq | [yellow-background]*Unknown (Acquire date)*
|===

Line 9 consists of 2 values, namely the values are "0 0".

Line 10 contains the values defined by line 8.

[NOTE]
The default values of some of these values has changed around linen 6.19 or 
earlier.

===== Subjects category
Line 12 the sub category contains information about subjects.

[yellow-background]*TODO describe what a subject is in the context of EnCase.*

Line 13 consists of 2 values, namely the values are "0 1".

The 14th line consist of the following tab (0x09) separated values.

[cols="1,1,5",options="header"]
|===
| Identifier number | Character in 14rd line | Meaning
| 1 | p | 
| 2 | n | 
| 3 | id | [yellow-background]*Unknown (Identifier, unique name)*
| 4 | nu | [yellow-background]*Unknown (Number)*
| 5 | co | [yellow-background]*Unknown (Comment)*
| 6 | gu | [yellow-background]*Unknown (GUID)*
|===

Line 15 consists of 2 values, namely the values are "0 0".

Line 16 contains the values defined by line 14.

[NOTE] The default values of some of these values has changed around linen 6.19 
or earlier.

==== FTK Imager (EWF-E01)
Some aspects of this section are:

* In FTK Imager (EWF-E01) the same header section defined twice.
* It is the first and second section of the first segment file. It is not found in other segment files.
* The header data itself is compressed using zlib. Note that the compression level can be none and therefore the header looks uncompressed.
* In FTK Imager the end of line character(s) is a newline (0x0a).

The 3rd and the 4th line consist of the following tab (0x09) separated values:

[cols="1,1,5",options="header"]
|===
| Identifier number | Character in 3rd line | Value in 4th line
| 1 | c | Case number
| 2 | n | Evidence number
| 3 | a | Unique description
| 4 | e | Examiner name
| 5 | t | Notes
| 6 | av | Version +
The FTK Imager version used to acquire the media
| 7 | ov | Platform +
The platform/operating system used to acquire the media
| 8 | m | Acquired date
| 9 | u | System date
| 10 | p | Password hash
| 11 | r | char
|===

For more information see section: <<header_values,Header values>>

==== EnCase 5 to 7 (EWF-L01)
The EnCase 4 to 7 (EWF-E01) header section specification is also used for the 
EnCase 5 to 7 (EWF-L01) format, with the following aspects:

* In EnCase 5 both the acquired date and system date are set to 0.
* In EnCase 6 and 7 both the acquired date and system date are set to Jan 1, 1970 00:00:00 (the time is dependent on the local timezone and daylight savings)

==== [[header_values]]Header values

[cols="1,1,5",options="header"]
|===
| Identifier | Description | Notes
| a | Unique description | Free form string +
Note that EnCase might not respond when this value is  large e.g. >= 1 MiB
| c | Case number | Free form string +
EnCase limits this string to 3000 - 1 characters
| n | Evidence number | Free form string +
EnCase limits this string to 3000 - 1 characters
| e | Examiner name | Free form string +
EnCase limits this string to 3000 - 1 characters
| t | Notes | Free form string +
EnCase limits this string to 3000 - 1 characters
| md | Model | Free form string +
EnCase limits this string to 3000 - 1 characters
| sn | Serial Number | Free form string +
EnCase limits this string to 3000 - 1 characters
| l | Device label | Free form string
| av | Version | Free form string +
EnCase limits this string to 12 - 1 characters
| ov | Platform | Free form string +
EnCase limits this string to 24 -1 characters
| m | Acquired date | In EnCase: +
String containing a date and time value +
E.g. 2002 3 4 10 19 59", which represents March 4, 2002 10:19:59. +
 +
In linen: +
String containing Unix 32-bit epoch timestamp +
E.g. "1142163845" which represents the date: March 12 2006, 11:44:05
| u | System date | In EnCase: +
String containing a date and time value +
E.g. 2002 3 4 10 19 59", which represents March 4, 2002 10:19:59. +
 +
In linen: +
String containing Unix 32-bit epoch timestamp +
E.g. "1142163845" which represents the date: March 12 2006, 11:44:05
| p | Password hash | String containing the password hash. +
If no password is set it should be simply the character '0'. 
| pid | Process identifier | String containing the process identifier (pid) number
| dc | [yellow-background]*Unknown* | 
| ext | Extents | extents contains: +
number of entries +
entries that consist of: S <1> <2> <3>
| r | Compression | Single character that represent the compression level
|===

[NOTE]
The restrictions were tested with Encase 7.02.01, older versions could have a 
restriction of 40 characters instead of 3000 characters.

[cols="1,1,5",options="header"]
|===
| Value of char | Meaning
| b | Best compression is used
| f | Fastest compression is used
| n | No compression is used
|===

===== Notes
There should not be a tab, carriage return and newline characters within the 
text in the 4th line. Or is there a method to escape these characters? 
`[ASR02]` states that these characters should not be used in the free form 
text. Need to confirm this, the specification only speaks of a newline 
character.

Currently the password has no a additional value than allow an application 
check it. The data itself is not protected using the password. The password 
hashing algorithm is unknown. Need to find out. And does the algorithm differ 
per EnCase version? probably not. The algorithm does not differ in EnCase
1 to 7. FTK Imager does not bother with a password.

=== [[volume_section]]Volume section
The volume section is identified in the section data type field as "volume". 
Some aspects of this section are:

* Defined in the EWF format `[ASR02]`.
* Found in EWF-E01 in EnCase 1 to 7 or linen 5 to 7 or FTK Imager, EWF-L01 in EnCase 5 to 7, and SMART (EWF-S01)
* Found after the header section of the first segment file. Not found in other segment files.

In the next paragraphs the various versions of the volume section are described.

==== EWF specification
The specification according to `[ASR02]`.

The additional volume section data is 94 bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Reserved according to `[ASR02]` +
Contains 0x01 +
[yellow-background]*Reserved for what?*
| 4 | 4 | | The chunk count +
Contains the number of chunks within the all segment files.
| 8 | 4 | | The number of sectors per chunk +
Contains 64 per default.
| 12 | 4 | | The number of bytes per sectors +
Contains 512 per default
| 16 | 4 | | The sectors count, the number of sectors within all segment files
| 20 | 20 | 0x00 | Reserved +
[yellow-background]*Reserved for what?*
| 40 | 45 | 0x00 | Padding
| 85 | 5 | | Signature (Reserved) +
Contains the EWF file header signature
| 90 | 4 | | Checksum +
Adler-32 of all the previous data within the additional volume section data.
|===

The chunk count is a 32-bit value this means it maximum of addressable chunks 
would be: 4294967295 (= 2^32 - 1). For a chunk size of 32768 x 4294967295 = 
about 127 TiB. The maximum segment file amount is 2^16 - 1 = 65535. This allows 
for an equal number of storage if a segment file is filled to its maximum 
number of chunks.

However libewf is restricted at 14295 segment files, due to the extension 
naming schema of the segment files.

==== SMART (EWF-S01)
The SMART format uses the EWF specification for this section.

In SMART the signature (reverse) value is the string "SMART" (0x53 0x4d 0x41 
0x52 0x54) instead of the file header signature.

==== FTK Imager, EnCase 1 to 7 and linen 5 to 7 (EWF-E01)
The specification for FTK Imager, EnCase 1 to 7 and linen 5 to 7.

The additional volume section data is 1052 bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 1 | | Media type +
See section: <<media_type,Media type>>
| 1 | 3 | 0x00 | [yellow-background]*Unknown (empty values)*
| 4 | 4 | | The chunk count +
Contains the number of chunks within the all segment files.
| 8 | 4 | | The number of sectors per chunk (or block size) +
Contains 64 per default. +
EnCase 5 is the first version which allows this value to be different than 64.
| 12 | 4 | | The number of bytes per sector
| 16 | 8 | | The sectors count +
Contains the number of sectors within all segment files +
This value probably has been changed in EnCase 6 from a 32-bit value to a 64-bit value to support media >2TiB
| 24 | 4 | | The number of cylinders of the C:H:S value +
Most of the time this value is empty (0x00)
| 28 | 4 | | The number of heads of the C:H:S value +
Most of the time this value is empty (0x00)
| 32 | 4 | | The number of sectors of the C:H:S value +
Most of the time this value is empty (0x00)
| 36 | 1 | | Media flags +
See section: Media flags
| 37 | 3 | 0x00 | [yellow-background]*Unknown (empty values)*
| 40 | 4 | | PALM volume start sector
| 44 | 4 | 0x00 | [yellow-background]*Unknown (padding/empty values)*
| 48 | 4 | | SMART logs start sector +
Contains an offset relative from the end of media +
E.g. a value of 10 would refer to sector = number of sectors - 10
| 52 | 1 | | Compression level +
(Introduced in EnCase 5) +
See section: <<compression_level,Compression level>>
| 53 | 3 | 0x00 | [yellow-background]*Unknown (empty values)* +
these values seem to be part of the compression type
| 56 | 4 | | The sector error granularity +
Contains the error block size +
(Introduced in EnCase 5)
| 60 | 4 | 0x00 | [yellow-background]*Unknown (empty values)*
| 64 | 16 | | Segment file set identifier +
Contains a GUID/UUID generated on the acquiry system probably used to uniquely identify a set of segment files +
(Introduced in EnCase 5)
| 80 | 963 | | [yellow-background]*Unknown (padding/empty values)*
| 1043 | 5 | | Signature (Reserved) +
Contains 0x00
| 1048 | 4 | | Checksum +
Adler-32 of all the previous data within the additional volume section data.
|===

[yellow-background]*TODO a value that could be in the volume is the raid stripe size*

[NOTE]
EnCase requires for media that contains no partition table that the is physical 
media flag is not set and vice versa. Other tools like FTK check the actual
storage media data.

==== EnCase 5 to 7 (EWF-L01)
The EWF-L01 format uses the EnCase 5 (EWF-E01) volume section specification. However:

* the volume type contains 0x0e
* the number of chunks is 0
* The number of bytes per sectors is some kind of block size value (4096), perhaps the source file system block size
* [yellow-background]*The sectors count, represents some other value because ( sector_size x sector_amount != total_size ) the total size is in the ltree section*

==== [[media_type]]Media type

[cols="1,1,5",options="header"]
|===
| Value | Identifier | Description
| 0x00 | | A removable storage media device
| 0x01 | | A fixed storage media device
| | | 
| 0x03 | | An optical disc (CD/DVD/BD)
| | | 
| 0x0e | | Logical Evidence File (LEV or L01)
| | | 
| 0x10 | | Physical Memory (RAM)
|===

[NOTE]
FTK imager versions, before version 2.9, set the storage media to fixed (0x01).
The exact version of FTK imager where this behavior changed is unknown.

==== [[media_flags]]Media flags

[cols="1,1,5",options="header"]
|===
| Value | Identifier | Description
| 0x01 | | Is an image file +
in FTK Imager, EnCase 1 to 7 this bit is always set, when not set EnCase seems to see the image file as a device
| 0x02 | | Is physical device or device type +
0 => a non physical device (logical) +
1 => a physical device
| 0x04 | | Fastbloc write blocker used
| 0x08 | | Tableau write blocker used +
This was added in EnCase 6.13
|===

[NOTE]
If both the the Fastbloc and Tableau write blocker media flags are set EnCase 
only shows the Fastbloc.

==== [[compression_level]]Compression level

[cols="1,1,5",options="header"]
|===
| Value | Identifier | Description
| 0x00 | | no compression
| 0x01 | | good compression
| 0x02 | | best compression
|===

=== Disk section
The disk section is identified in the section data type field as "disk". Some 
aspects of this section are:

* Not defined in the EWF format `[ASR02]`.
* Not found in SMART (EWF-S01).

According to `[COH]` the disk section is the same as the volume section. This 
was confirmed with a disk section in an FTK Imager 2.3 (EWF-E01) image.

[NOTE]
The disk section was found only in FTK Imager 2.3 when acquiring a physical 
disk not a floppy. This requires additional research. Is the disk section some 
old method to differentiate between a partition (volume) image or a physical 
disk image?

=== Data section
The data section is identified in the section data type field as "data". Some 
aspects of this section are:

* It is not defined in the EWF format `[ASR02]`.
* Found in EWF-E01 in EnCase 1 to 7 or linen 5 to 7 or FTK Imager, and EWF-L01 in EnCase 5 to 7. Not found in SMART (EWF-S01).
* For multiple segment files it does not reside in the first segment file. For a single segment file it does.
* Found after the last table2 section in a single segment file or for multiple segment files at the start of the segment files, except for the first.
* The data section has data it should should contain the same information as the volume section.

==== FTK Imager, EnCase 1 to 7 and linen 5 to 7 (EWF-E01)
The additional data section data is 1052 bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 1 | | Media type +
See section: <<media_type,Media type>>
| 1 | 3 | 0x00 | [yellow-background]*Unknown (empty values)*
| 4 | 4 | | The chunk count +
Contains the number of chunks within the all segment files.
| 8 | 4 | | The block size (number of sectors per chunk) +
Contains 64 per default. +
EnCase 5 is the first version which allows this value to be different than 64.
| 12 | 4 | | The number of bytes per sector
| 16 | 8 | | The sectors count +
Contains  the number of sectors within all segment files +
This value probably has been changed in EnCase 6 from a 32-bit value to a 64-bit value to support media >2TiB
| 24 | 4 | | The number of cylinders of the C:H:S value +
Most of the time this value is empty (0x00)
| 28 | 4 | | The number of heads of the C:H:S value +
Most of the time this value is empty (0x00)
| 32 | 4 | | The number of sectors of the C:H:S value +
Most of the time this value is empty (0x00)
| 36 | 1 | | Media flags +
See section: <<media_flags,Media flags>>
| 37 | 3 | 0x00 | [yellow-background]*Unknown (empty values)*
| 40 | 4 | | PALM volume start sector
| 44 | 4 | 0x00 | [yellow-background]*Unknown (padding/empty values)*
| 48 | 4 | | SMART logs start sector +
Contains an offset relative from the end of media +
E.g. a value of 10 would refer to sector = number of sectors - 10
| 52 | 1 | | Compression level +
(Introduced in EnCase 5) +
See section: <<compression_level,Compression level>>
| 53 | 3 | 0x00 | [yellow-background]*Unknown (empty values)* +
[yellow-background]*These values seem to be part of the compression type*
| 56 | 4 | | The sector error granularity +
Contains the error block size +
(Introduced in EnCase 5)
| 60 | 4 | 0x00 | [yellow-background]*Unknown (empty values)*
| 64 | 16 | | Segment file set identifier +
Contains a GUID/UUID generated on the acquiry system probably used to uniquely identify a set of segment files +
(Introduced in EnCase 5)
| 80 | 963 | | [yellow-background]*Unknown (padding/empty values)*
| 1043 | 5 | | Signature (Reserved) +
Contains 0x00
| 1048 | 4 | | Checksum +
Adler-32 of all the previous data within the additional data section data.
|===

[NOTE]
In Logicube products (Talon (firmware predating April 2013) and Forensic 
dossier (before version 3.3.3RC16)) the checksum is not calculated and set to 0.

==== EnCase 5 to 7 (EWF-L01)
The EWF-L01 format uses the EnCase 5 (EWF-E01) data section specification. However:

* the data type contains 0x0e
* the number of chunks is 0
* The number of bytes per sectors is some kind of block size value (4096), perhaps the source file system block size
* [yellow-background]*The sectors count, represents some other value because ( sector_size x sector_amount != total_size ) the total size is in the ltree section*

=== Sectors section
The sectors section is identified in the section data type field as "sectors". 
Some aspects of this section are:

* Not defined in the EWF format `[ASR02]`.
* Found in EWF-E01 in EnCase 2 to 7, or linen 5 to 7 or FTK Imager, EWF-L01 in EnCase 5 to 7. Not found in EnCase 1 (EWF-E01) or SMART (EWF-S01).
* The first sectors section can be found after the volume section in the first segment file or at the after the data section in other segment files. Successive sector data sections are found after the sector table2 section.

The sectors section contains the actual chunks of media data.

* The sectors section can contain multiple chunks.
* The default size of a chunk is 32768 bytes of data (64 standard sectors, with a size of 512 bytes per sector). It is possible in EnCase 5 and 6 and linen 5 and 6 to change the number of sectors per block to 64, 128, 256, 1024, 2048, 4096, 8192, 16384 or 32768. In EnCase 7 and linen 7 this has been reduced to 64, 128, 256, 1024.

==== Data chunk
The first chunk is often located directly after the section descriptor, 
although the format does not require this.

When the data is compressed and the compressed data (with checksum) is larger 
than the uncompressed data (without the checksum) the data chunk is stored 
uncompressed. The default size of a chunk is 32768 bytes of data (64 standard 
sectors).

An uncompressed data chunk is variable of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | ... | | Uncompressed chunk data
| ... | 4 | | Checksum +
Adler-32 of the chunk data
|===

The compressed data chunk consist of zlib compressed data. The checksum of the 
compressed data chunk is part the zlib compressed data format. See section:
<<compression,Compression>>.

==== Optical disc images
For a MODE‑1 CD-ROM optical disc image EnCase only seems to support 2048 bytes 
per sector (the data).

The raw sector size of a MODE-1 CD-ROM is 2352 bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 16 | | Synchronization bytes
| 16 | 2048 | | Data
| 2054 | 4 | | Error detection
| 2058 | 8 | | [yellow-background]*Unknown (Empty values)*
| 2066 | 276 | | Error correction
|===

[yellow-background]*TODO add information about Mode-2 and Mode-XA*

=== Table section
The table section is identified in the section data type field as "table". Some 
aspects of this section are:

* Defined in the EWF format `[ASR02]`.
* Found in EWF-E01 in EnCase 1 to 7 or linen 5 to 7 or FTK Imager, EWF-L01 in EnCase 5 to 7, and SMART (EWF-S01)

[NOTE]
The offsets within the section descriptor are 8 bytes (64 bits) of size while 
the offsets in the table entry array are 4 bytes (32 bits) of size.

In the next paragraphs the various versions of the table section are described.

==== EWF specification
Some aspects of the table section according to the EWF specification are:

* The first table section resides after the volume section in the first segment file or after the file header in other segment files.
* It can be found in every segment file.

The table section consists of:

* the table header
* an array of table entries
* the data chunks

===== Table header
The table header is 24 bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | The number of entries +
[yellow-background]*Note that according to `[ASR02]` it contains 0x01*
| 4 | 16 | 0x00 | Padding
| 20 | 4 | | Checksum +
Adler-32 of all the previous data within the additional volume section data.
|===

According to `[ASR02]` the table can hold 16375 entries if more entries are 
required an additional table section should be created.

===== Table entry
The table entry is 4 bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Chunk data offset
|===

The most significant bit (MSB) in the chunk data offset indicates if the chunk 
is compressed (1) or uncompressed (0).

A chunk data offset points to the start of the chunk of media data, which 
resides in the same table section within the segment file. The offset contains 
a value relative to the start of the file.

===== Data chunk
The first chunk is often located directly after the last table entry, although 
the format does not require this.

A data chunk is always compressed even when no compression is required. This 
approach provides a checksum for each chunk. The default size of a chunk is 
32768 bytes of data (64 standard sectors). The resulting size of the 
"compressed" chunk can therefore be larger than the default chunk size. 
[yellow-background]*This however was deducted from the behavior of FTK Imager 
for EWF-S01.*

The compressed data chunk consist of zlib compressed data. The checksum of the 
compressed data chunk is part the zlib compressed data format. See section: 
<<compression,Compression>>.

==== SMART (EWF-S01)
The table section in the SMART (EWF-S01) format is equivalent to that of the 
EWF specification.

==== EnCase 1 (EWF-E01)
Some aspects of this section are:

* The table section resides after the volume section in the first segment file or after the file header in other segment files.
* It can be found in every segment file.

The table section consists of:

* the table header
* an array of table entries
* the table footer
* the data chunks

===== Table header
The table header is 24 bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | The number of entries
| 4 | 16 | 0x00 | Padding
| 20 | 4 | | Checksum +
Adler-32 of all the previous data within the additional volume section data.
|===

The table can hold 16375 entries if more entries are required an additional table section should be created.

===== Table entry
The table entry is 4 bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Chunk data offset
|===

The most significant bit (MSB) in the chunk data offset indicates if the chunk 
is compressed (1) or uncompressed (0).

A chunk data offset points to the start of the chunk of media data, which 
resides in the same table section within the segment file. The offset contains 
a value relative to the start of the file.

===== Table footer
The table footer is 4 bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Checksum +
Adler-32 of the offset array
|===

===== Data chunk
The first chunk is often located directly after the table footer, although the 
format does not require this.

When the data is compressed and the compressed data (with checksum) is larger 
than the uncompressed data (without the checksum) the data chunk is stored 
uncompressed. The default size of a chunk is 32768 bytes of data (64 standard 
sectors).

An uncompressed data chunk is variable of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | ... | | Uncompressed chunk data
| ... | 4 | | Checksum +
Adler-32 of the chunk data
|===

The compressed data chunk consist of zlib compressed data. The checksum of the 
compressed data chunk is part the zlib compressed data format. See section: 
<<compression,Compression>>

==== FTK Imager and EnCase 2 to 5 and linen 5 (EWF-E01)
Some aspects of this section are:

* The table section resides after the sectors section.
* It can be found in every segment file.
* The data chunks are no longer stored in this section but in the sectors section instead.
* The table2 section contains a mirror copy of the table section. In EWF-E01 it is always present.

The table section consists of:

* the table header
* an array of table entries
* the table footer

===== Table header
The sector table header is 24 bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | The number of entries
| 4 | 16 | 0x00 | Padding
| 20 | 4 | | Checksum +
Adler-32 of all the previous data within the additional volume section data.
|===

The table section can hold 16375 entries. A new table section should be created 
to hold more entries. Both FTK Imager and EnCase 5 can handle more than 16375, 
FTK 1 cannot. To contain more than 16375 chunks new sectors, table and table2 
sections need to be created after the table2 section.

===== Table entry
The table entry is 4 bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Chunk data offset
|===

The most significant bit (MSB) in the chunk data offset indicates if the chunk 
is compressed (1) or uncompressed (0).

A chunk data offset points to the start of the chunk of media data, which 
resides in the preceding sectors section within the segment file. The offset 
contains a value relative to the start of the file.

===== Table footer
The table footer is 4 bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Checksum +
Adler-32 of the offset array
|===

==== EnCase 6 to 7 and linen 6 to 7 (EWF-E01)
Some aspects of this section are:

* Every segment file contains its own table section.
* It resides after the sectors section.
* The data chunks are no longer stored in this section but in the sectors section instead.
* The table2 section contains a mirror copy of the table section. In EWF-E01 it is always present.

The table section consists of:

* the table header
* an array of table entries
* the table footer

===== Table header
The sector table header is 24 bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | The number of entries
| 4 | 4 | 0x00 | Padding
| 8 | 8 | | The table base offset
| 16 | 4 | 0x00 | Padding
| 20 | 4 | | Checksum +
Adler-32 of all the previous data within the additional volume section data.
|===

As of EnCase 6 the number of entries is no longer restricted to 16375 entries. 
The new limit seems to be 65534.

===== Table entry
The table entry is 4 bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Chunk data offset
|===

The most significant bit (MSB) in the chunk data offset indicates if the chunk 
is compressed (1) or uncompressed (0).

A chunk data offset points to the start of the chunk of media data, which 
resides in the preceding sectors section within the segment file. The offset 
contains a value relative to the start of the file.

In EnCase 6.7.1 the sectors section can be larger than 2048Mb. The table 
entries offsets are 31 bit values in EnCase6 the offset in a table entry value 
will actually use *the full 32 bit* if the 2048Mb has been exceeded. This 
behavior is no longer present in EnCase 6.8 so it is assumed to be a bug. 
Libewf currently assumes that the if the 31 bit value overflows the following 
chunks are uncompressed. This allows EnCase 6.7.1 faulty EWF files to be 
converted by libewf.

===== Table footer
The table footer is 4 bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Checksum +
Adler-32 of the offset array
|===

==== EnCase 6 to 7 (EWF-L01)
The EWF-L01 format uses the EnCase 6 to 7 (EWF-E01) table section specification.

=== Table2 section
The table2 section is identified in the section data type field as "table2". 
Some aspects of this section are:

* Not defined in the EWF format `[ASR02]`.
* Found in EWF-E01 in EnCase 2 to 7, or linen 5 to 7 or FTK Imager, EWF-L01 in EnCase 5 to 7. Not found in EnCase 1 (EWF-E01) or SMART (EWF-S01).
* Uses the same format as the table section.
* Resides directly after the table section.

==== FTK Imager and EnCase 2 to 7 and linen 5 to 7 (EWF-E01)
The table2 section contains a mirror copy of the table section. Probably 
intended for recovery purposes.

==== EnCase 5 to 7 (EWF-L01)
The EWF-L01 format uses the EWF-E01 table2 section specification.

=== Next section
The next section is identified in the section data type field as "next". Some 
aspects of this section are:

* Defined in the EWF format `[ASR02]`.
* Found in EWF-E01 in EnCase 1 to 7 or linen 5 to 7 or FTK Imager, EWF-L01 in EnCase 5 to 7, and SMART (EWF-S01)
* The last section within a segment other than the last segment file.
* The offset to the next section in the section descriptor of the next section point to itself (the start of the next section).
* It should be the last section in a segment file, other than the last segment file.

==== SMART (EWF-S01)
It resides after the table or table2 section.

==== FTK Imager, EnCase and linen (EWF-E01)
It resides after the data section in a single segment file or for multiple 
segment files after the table2 section.

In the EnCase (EWF-E01) format the size in the section descriptor is 0 instead 
of 76 (the size of the section descriptor).

[NOTE]
FTK imager versions before 2.9 sets the section size to 76. At the moment it is 
unknown in which version this behavior was changed.

=== Ltypes section
The ltypes section is identifier in the section data type field as "ltypes". 
Some aspects of this section are:

* Found in EWF-L01 in of EnCase 7
* Found in the last segment file after table2 section before tree section.

The additional ltypes section data is 6 bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 2 | | [yellow-background]*Unknown*
| 2 | 2 | | [yellow-background]*Unknown*
| 4 | 2 | | [yellow-background]*Unknown*
|===

=== Ltree section
The ltree section is identifier in the section data type field as "ltree". Some 
aspects of this section are:

* Found in EWF-L01 in of EnCase 5 to 7
* Found in the last segment file after ltypes section and before data section.

The ltree section consists of:

* ltree header
* ltree data

==== Ltree header
The ltree header is 6 bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 16 | | Integrity hash +
Contains the MD5 of the ltree data
| 16 | 8 | | Data size
| 24 | 4 | | Checksum +
Adler-32 of all the data within the ltree header where the checksum value itself is zeroed out.
| 28 | 20 | | [yellow-background]*Unknown (empty values)*
|===

==== Ltree data
The ltree data string consists of an UTF-16 little-endian encoded string 
without the UTF-16 endian byte order mark.

The ltree data string contains the following information:

[cols="1,1,5",options="header"]
|===
| Line number | Value | Description
| 1 | 5 | The number of categories provided
| 2 | rec | Probably the type of information provided
| 3 | | Identifier for the values in the 4th line
| 4 | | The data for the different identifiers in the 3rd line
| 5 | | (an empty line)
| 6 | perm | Information about file permissions
| 7 | | 
| 8 | | Identifier for the values in the section
| 9 | | 
| 10 | | 
| 11 | | 
| 12 | | 
| 13 | | (an empty line)
| 14 | srce | Probably the type of information provided (the data source)
| 15 | | 
| 16 | | Identifier for the values in the section
| 17 | | 
| 18 | | 
| 19 | | 
| 20 | | 
| 21 | | (an empty line)
| 22 | sub | Probably the type of information provided
| 23 | | 
| 24 | | Identifier for the values in the section
| 25 | | 
| 26 | | (an empty line)
| 27 | entry | Information about file entries
| 28 | | 
| 29 | | Identifier for the values in the section
| 30 | | The ltree entries of files and directories
| ... | | (an empty line)
|===

[NOTE]
The actual line numbering can vary.

The end of line character(s) is a newline (0x0a).

==== Records category
The rec category contains information about records.

The 3rd and the 4th line consist of the following tab (0x09) separated values.

[cols="1,1,5",options="header"]
|===
| Identifier number | Character in 3rd line | Value in 4th line
| 1 | tb | Total bytes +
The size of the logical file data (media data)
| 2 | cl | [yellow-background]*Unknown (Clusters?)*
| 3 | n | [yellow-background]*Unknown* +
(introduced in EnCase 6.19)
| 4 | fp | [yellow-background]*Unknown* +
(introduced in EnCase 7)
| 5 | pg | [yellow-background]*Unknown* +
(introduced in EnCase 7)
| 6 | lg | [yellow-background]*Unknown* +
(introduced in EnCase 7)
| 7 | ig | [yellow-background]*Unknown* +
(introduced in EnCase 7)
|===

==== Permissions category
The perm category contains information about file permissions.

Line 6 consist of perm

Line 7 consists of 2 values.

The 8th line consist of the following tab (0x09) separated values.

[cols="1,1,5",options="header"]
|===
| Identifier number | Character in 8th line | Meaning
| 1 | p | 
| 2 | n | Name
| 3 | s | NT security identifier (SID)
| 4 | pr | Property
| 5 | nta | [yellow-background]*Unknown (NT permission (ACE)?)*
| 6 | nti | [yellow-background]*Unknown (Permission?)*
| 7 | nts | [yellow-background]*Unknown (Permission?)* +
(Removed in EnCase 6)
|===

[yellow-background]*Notes: Property: (2 => allow, empty => owner, 1 => group)*

==== Sources category
Line 12 the srce category contains information about sources

[yellow-background]*TODO describe what a source is in the context of EnCase.*

Line 13 consists of 2 values, namely the values are "0 1".

The 14th line consist of the following tab (0x09) separated values.

[cols="1,1,5",options="header"]
|===
| Identifier number | Character in 9th line | Meaning
| 1 | p |
| 2 | n |
| 3 | id | [yellow-background]*Unknown (Identifier, unique name)*
| 4 | ev | [yellow-background]*Unknown (Evidence number)*
| 5 | do | [yellow-background]*Unknown* +
(introduced in EnCase 7.9)
| 6 | loc | [yellow-background]*Unknown* +
(introduced in EnCase 7.9)
| 7 | se | [yellow-background]*Unknown (Serial number)* +
(introduced in EnCase 7.9)
| 8 | mfr | [yellow-background]*Unknown* +
(introduced in EnCase 7.9)
| 9 | mo | [yellow-background]*Unknown (Model)* +
(introduced in EnCase 7.9)
| 10 | tb | [yellow-background]*Unknown (Total bytes)*
| 11 | lo | [yellow-background]*Unknown (Logical offset)* +
-1 when not set
| 12 | po | [yellow-background]*Unknown (Physical offset)* +
-1 when not set
| 13 | ah | [yellow-background]*Unknown (Acquire hash)*
| 14 | sh | [yellow-background]*Unknown* +
(introduced in EnCase 6.19)
| 15 | gu | [yellow-background]*Unknown (GUID)* +
Contains "0" if not set
| 16 | pgu | [yellow-background]*Unknown (Physical GUID)* +
Contains "0" if not set +
(introduced in EnCase 7)
| 17 | aq | [yellow-background]*Unknown (Acquire date)*
| 18 | ip | [yellow-background]*Unknown* +
(introduced in EnCase 7.9)
| 19 | si | [yellow-background]*Unknown* +
(introduced in EnCase 7.9)
| 20 | ma | [yellow-background]*Unknown* +
(introduced in EnCase 7.9) +
Seen: "0"
| 21 | dt | [yellow-background]*Unknown* +
(introduced in EnCase 7.9) +
Seen: "f"
|===

"Acquire date" is in the form of: "1142163845", which is a Unix epoch time 
stamp and represents the date: March 12 2006, 11:44:05.

==== Subjects category
The 21th line consist of the following tab (0x09) separated values.

[yellow-background]*TODO describe what a subject is in the context of EnCase.*

[cols="1,1,5",options="header"]
|===
| Identifier number | Character in 15th line | Meaning
| 1 | p | 
| 2 | n | 
| 3 | id | [yellow-background]*Unknown (Identifier, unique name)*
| 4 | nu | [yellow-background]*Unknown (Number)*
| 5 | co | [yellow-background]*Unknown (Comment)*
| 6 | gu | [yellow-background]*Unknown (GUID)*
|===

==== Ltree entries
===== EnCase 5 and 6 (EWF-L01)
The 29th line consist of the following tab (0x09) separated values.

[cols="1,1,5",options="header"]
|===
| Identifier number | Character in 29th line | Meaning
| 1 | p | Is parent +
1 => if the single file entry is a directory +
(null) => if single file entry is a file
| 2 | n | Name
| 3 | id | [yellow-background]*Unknown*
| 4 | opr | Flags +
See section: <<file_entry_flags,File entry flags>>
| 5 | src | Possible the source identifier
| 6 | sub | Possible the subject identifier
| 7 | cid | [yellow-background]*Unknown*
| 8 | jq | [yellow-background]*Unknown*
| 9 | cr | Creation date
| 10 | ac | Access date +
[yellow-background]*(precision is date only)*
| 11 | wr | (File) modification (last written) date
| 12 | mo | (File system) entry modification date
| 13 | dl | [yellow-background]*Unknown*
| 14 | aq | [yellow-background]*Unknown*
| 15 | ha | Hash +
The MD5 hash of the file data
| 16 | ls | File size +
The file size specified in bytes +
If the file size is 0 the data size should be 1
| 17 | du | Duplicate data offset +
Relative from the start of the media data
| 18 | lo | [yellow-background]*Unknown (Logical Offset?)*
| 19 | po | [yellow-background]*Unknown (Physical Offset?)* +
[yellow-background]*The segment file in which the start of the data is stored, -1 for a single segment file ?*
| 20 | mid | [yellow-background]*Unknown (identifier?)* +
(introduced in EnCase 6.19)
| 21 | cfi | [yellow-background]*Unknown* +
(introduced in EnCase 6.14)
| 22 | be | Binary extents +
See section: <<binary_extents_value,Binary extents value>>
| 23 | pm | [yellow-background]*Unknown (permissions index?)* +
[yellow-background]*-1 has a special meaning?*
| 24 | lpt | [yellow-background]*Unknown* +
(introduced in EnCase 6.19)
|===

"Creation date", "Access date" and " Last written date" are in the form of: 
"1142163845", which is a Unix epoch time stamp and represents the date: March 
12 2006, 11:44:05.

The "ha" value (Hash) consist of a MD5 hash string when file entries are 
hashed. If the "ha" value contains "00000000000000000000000000000000." this
means the MD5 hash is not set.

====== Ltree file entries
The ltree entries of files and directories consist of entries starting with: 0 
followed by the number of sub file entries.

The entries of files and directories:

[cols="1,1,5",options="header"]
|===
| Line number | Value | Description
| 1 | (empty) | The root directory
| 2 | | The target drive/mount point
| 3 | | The actual single file entries
|===

===== EnCase 7 (EWF-L01)
The 29th line consist of the following tab (0x09) separated values.

[cols="1,1,5",options="header"]
|===
| Identifier number | Character in 29th line | Meaning
| 1 | mid | [yellow-background]*Unknown (identifier?)*
| 2 | ls | File size +
The file size specified in bytes +
If the file size is 0 the data size should be 1
| 3 | be | Binary extents +
See section: <<binary_extents_value,Binary extents value>>
| 4 | id | [yellow-background]*Unknown*
| 5 | cr | Creation date
| 6 | ac | Access date
| 7 | wr | (File) modification (last written) date
| 8 | mo | (File system) entry modification date
| 9 | dl | [yellow-background]*Unknown*
| 10 | sig | [yellow-background]*Unknown* +
(Introduced in EnCase 7)
| 11 | ha | Hash +
The MD5 hash of the file data
| 12 | sha | SHA1 hash +
Judging by the size this value is assumed to be the SHA1 hash of the file data, does not seem to be currently set by EnCase +
(Introduced in EnCase 7)
| 13 | ent | [yellow-background]*Unknown* +
(Introduced in EnCase 7.9)
| 14 | snh | [yellow-background]*Unknown (Short or 8.3 name)* +
Contains "13 FILENAME.EXT" where the first number is the number of characters in the name? +
(Introduced in EnCase 7.9)
| 15 | p | Is parent +
1 => if the single file entry is a directory +
(null) => if single file entry is a file
| 16 | n | Name
| 17 | du | Duplicate data offset +
Relative from the start of the media data
| 18 | lo | [yellow-background]*Unknown (Logical Offset?)*
| 19 | po | [yellow-background]*Unknown (Physical Offset?)*
[yellow-background]*The segment file in which the start of the data is stored, -1 for a single segment file ?*
| 20 | pm | [yellow-background]*Unknown (permissions index?)* +
[yellow-background]*-1 has a special meaning?*
| 21 | oes | [yellow-background]*Unknown (Original extents)* +
(Introduced in EnCase 7)
| 22 | opr | Flags +
See section: <<file_entry_flags,File entry flags>>
| 23 | src | [yellow-background]*Unknown (Possible the source identifier)*
| 24 | sub | [yellow-background]*Unknown (Possible the subject identifier)*
| 25 | cid | [yellow-background]*Unknown*
| 26 | jq | [yellow-background]*Unknown*
| 27 | alt | [yellow-background]*Unknown* +
(Introduced in EnCase 7)
| 28 | ep | [yellow-background]*Unknown* +
(Introduced in EnCase 7)
| 29 | aq | [yellow-background]*Unknown*
| 30 | cfi | [yellow-background]*Unknown*
| 31 | sg | [yellow-background]*Unknown* +
(Introduced in EnCase 7)
| 32 | ea | [yellow-background]*Unknown* +
(Introduced in EnCase 7.9)
| 33 | lpt | [yellow-background]*Unknown*
|===

If the "ha" value contains "00000000000000000000000000000000." this means the 
MD5 hash is not set. The same applies for the "sha" value when it contains 
"0000000000000000000000000000000000000000" the SHA1 has is not set.

====== Original extents
[yellow-background]*TODO: add some text*

....
1 30a555b 30a6000 12011ae00 9008d7 3f 43 1 12011ae00 30a6000 120113 30a6 9008d7 18530
....

====== Unknonw ea
[yellow-background]*TODO: add some text*

Contains base-16 encoded data:
....
0x00000000  00 00 00 00 01 0b 00 00  00 01 00 00 00 41 00 74  .............A.t
0x00000010  00 74 00 72 00 69 00 62  00 75 00 74 00 65 00 73  .t.r.i.b.u.t.e.s
0x00000020  00 00 00 00 00 01 00 00  00 01 04 00 00 00 01 00  ................
0x00000030  00 00 45 00 46 00 53 00  00 00 00 00 01 00 00 00  ..E.F.S.........
0x00000040  00 0c 00 00 00 02 00 00  00 53 00 65 00 71 00 75  .........S.e.q.u
0x00000050  00 65 00 6e 00 63 00 65  00 20 00 49 00 44 00 00  .e.n.c.e. .I.D..
0x00000060  00 31 00 00 00 01 00 00  00 00 18 00 00 00 08 00  .1..............
0x00000070  00 00 4c 00 6f 00 67 00  69 00 63 00 61 00 6c 00  ..L.o.g.i.c.a.l.
0x00000080  20 00 73 00 65 00 71 00  75 00 65 00 6e 00 63 00   .s.e.q.u.e.n.c.
0x00000090  65 00 20 00 6e 00 75 00  6d 00 62 00 65 00 72 00  e. .n.u.m.b.e.r.
0x000000a0  00 00 31 00 39 00 33 00  31 00 31 00 45 00 44 00  ..1.9.3.1.1.E.D.
0x000000b0  00 00                                             ..
....

====== Ltree file entries
The ltree entries of files and directories consist of entries starting with: 26 
followed by the number of sub file entries.

The entries of files and directories:

[cols="1,1,5",options="header"]
|===
| Line number | Value | Description
| 1 | LogicalEntries | The root directory
| 2 | | The target drive/mount point
| 3 | | The actual single file entries
|===

===== [[file_entry_flags]]File entry flags

[cols="1,1,5",options="header"]
|===
| Value | Identifier | Description
| | | 
| 0x00000008 | | Archive
| | | 
| 0x00400000 | | [yellow-background]*Unknown (is file?)*
| | | 
| 0x01000000 | | [yellow-background]*Unknown*
| 0x02000000 | | [yellow-background]*Unknown*
| 0x04000000 | | Data is sparse +
See remarks below.
|===

If the sparse data flag is set:

* the data size should be 1 and data should consist of a single byte value.
* the data size should be equal to the file size and data should be the same.

If the duplicate data offset value is not set the single byte value in the data 
should be used to reconstruct the file data. E.g. if the file size is 4096 and 
the data contains the byte value 0x00 the resulting file should consists of 
4096 x 0x00 byte values.

If the duplicate data offset value is set the single byte in the data is 
ignored and the duplicate data offset refers to the location where the data 
stored.

===== [[binary_extents_value]]Binary extents value
The binary extents value contains 3 values separated by a space:
....
Unknown Offset Size
....

Where:

* unknown always is 1 ([yellow-background]*could this be the number of extents?*)
* extent data offset, relative from the start of the media data
* extent data size

The offset and size are specified in hexadecimal values.

[yellow-background]*Note: Contains 1 value for the first single file entry.*

=== Map section
Some aspects of this section are:

* Found in EWF-L01 in of EnCase 7 (First seen in EnCase 7.4.1.10)
* Found in the last segment file after data section before done section.

The map consists of:

* map string
* map entries array

==== Map string
The map string consists of an UTF-16 little-endian encoded string without the 
UTF-16 endian byte order mark.

The map string contains the following information:

[cols="1,1,5",options="header"]
|===
| Line number | Value | Description
| 1 | 1 | The number of categories provided
| 2 | r | Probably the type of information provided
| 3 | c | Identifier for the values in the 4th line
| 4 | | The data for the different identifiers in the 3rd line
| 5 | | (an empty line)
|===

===== Map string values

[cols="1,1,5",options="header"]
|===
| Identifier number | Character in 29th line | Meaning
| 1 | C | Number of map entries (count)
|===

The number of map entries should match the number of file entries in the ltree.

==== Map entry
A map entry is 24 bytes of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | [yellow-background]*Unknown*
| 4 | 4 | | [yellow-background]*Unknown (empty values or part of previous value)*
| 8 | 16 | | [yellow-background]*Unknown*
|===

=== Session section
The session section is identifier in the section data type field as "session". Some aspects of this section are:

* It is not defined in the EWF format `[ASR02]`.
* It is not found in SMART (EWF-S01) and FTK Imager (EWF-E01).
* It is found in EnCase 5 and 6 (EWF-E01) files.
* It is only added to the last segment file for images of optical disc (CD/DVD/BD) media.
* It is found after the data section and before the error2 section.

The session section data consists of:

* The session header
* The session entries array
* The session footer

==== Session header
The session header is 36 byte of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Number of sessions
| 4 | 28 | | [yellow-background]*Unknown (empty values)*
| 32 | 4 | | Checksum +
Adler-32 of all the previous data within the additional session section data.
|===

==== Session entry
A session entry is 32 byte of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Flags
| 4 | 4 | | Start sector
| 8 | 24 | | [yellow-background]*Unknown (empty values)*
|===

EnCase stores audio tracks as 0 byte data with a sector size of 2048.

[NOTE]
For a CD the first session sector is stored as 16, although the actual session 
starts at sector 0. Could this value be overloaded to indicate the size of the 
reserved space between the start of the session and the ISO 9660 volume 
descriptor.

==== Session flags

[cols="1,1,5",options="header"]
|===
| Value | Identifier | Description
| 0x00000001 | | If set the track is an audio track otherwise the track is a data track
|===

==== Session footer
The session footer is 4 byte of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Checksum +
Adler-32 of all the data within the session entries array
|===

=== Error2 section
The error2 section is identifier in the section data type field as "error2". 
Some aspects of this section are:

* It is not defined in the EWF format `[ASR02]`.
* It is not found in SMART (EWF-S01).
* It is found in, EnCase 3 to 7 and linen 5 to 7 (EWF-E01) files.
* It is only added to the last segment file when errors were encountered while reading the input.

[yellow-background]*TODO check FTK Imager, EnCase 1 and 2 for presence of the 
error2 section.*

It contains the sectors that have read errors. The sector where a read error 
occurred are filled with zero's during acquiry by EnCase.

The error2 section data consists of:

* The error2 header
* The error2 entries array
* The error2 footer

==== Error2 header
The error2 header is 520 byte of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Number of entries
| 4 | 512 | | [yellow-background]*Unknown (empty values)*
| 516 | 4 | | Checksum +
Adler-32 of all the previous data within the error2 header data.
|===

==== Error2 entry
An error2 entry is 8 byte of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Start sector
| 4 | 4 | | The number of sectors
|===

==== Error2 footer
The error2 footer is 4 byte of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 4 | | Checksum +
Adler-32 of all the data within the error2 entries array
|===

=== Digest section
The digest section is identified in the section data type field as "digest". 
Some aspects of this section are:

* It is found in EnCase 6 to 7 files, as of EnCase 6.12 and linen 6.12 (EWF-E01).

The digest section contains a MD5 and/or SHA1 hash of the data within the chunks.

The additional digest section data is 80 byte of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 16 | | MD5 hash of the media data
| 16 | 20 | | SHA1 hash of the media data
| 36 | 40 | 0x00 | Padding
| 76 | 4 | | Checksum +
Adler-32 of all the previous data within the additional digest section data.
|===

=== Hash section
The hash section is identified in the section data type field as "hash". Some 
aspects of this section are:

* It is defined in the EWF format `[ASR02]`.
* It is found in SMART (EWF-S01) and FTK Imager, EnCase 1 to 7 and linen 5 to 7 (EWF-E01) files.
* It is not found in EnCase 5 (EWF-L01).
* The hash section is optional, it does not need to be present. If it does it resides in the last segment file before the done section.

The hash section contains a MD5 hash of the data within the chunks.

The additional digest section data is 36 byte of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 16 | | MD5 hash of the media data
| 16 | 16 | | [yellow-background]*Unknown*
| 32 | 4 | | Checksum +
Adler-32 of all the previous data within the additional hash section data.
|===

==== Notes
Observations regarding the unknown value:

* is zero in SMART
* is zero in EnCase 3 and below
* in EnCase 4 the first 4 bytes are 0, the next 8 bytes seem random, the last 4 bytes seem fixed
* in EnCase 5 and 6 the first 8 bytes seem random, the last 8 bytes equal the file header signature
* in linen 5 the first and last set of 4 bytes seem the same, the second set of 4 bytes seem to be random, the third set of 4 bytes seem to contain a piece of the file header signature
* in linen 6 the first and third set of 4 bytes seem random, the second and last set of 4 bytes seem to be the same
* EnCase5 seems to contain a GUID of the acquired device?

Test with EnCase 4 show that:

* The value does not equal the checksum of the media data
* Does not differentiate for the same media acquired within the same program session, using different formats, but differ for different media and different program sessions

=== Done section
The done section is identified in the section data type field as "done". Some 
aspects of this section are:

* It is defined in the EWF format `[ASR02]`.
* It is found in SMART (EWF-S01), FTK Imager, EnCase 1 to 7 and linen 5 to 7 (EWF-E01) and EnCase 5 (EWF-L01) files.
* The done section is the last section within the last segment file.
* The offset to the next section in the section descriptor of the done section point to itself (the start of the done section).
* It should be the last section in the last segment file.

==== SMART (EWF-S01)
It resides after the table or table2 section.

==== FTK Imager, EnCase and linen (EWF-E01)
It resides after the data section in a single segment file or for multiple 
segment files after the table2 section.

In the EnCase (EWF-E01) format the size in the section descriptor is 0 instead 
of 76 (the size of the section descriptor).

[NOTE]
FTK imager versions before 2.9 sets the section size to 76. At the moment it is 
unknown in which version this behavior was changed.

==== Incomplete section
The incomplete section is identified in the section data type field as 
"incomplete".

This section is seen rarely. It was seen in an EnCase 6.13 (EWF-E01) file as 
the last last section within the last segment file. The incomplete section was 
preceded by a hash and digest section, although later in the set of EWF files 
another hash and digest section were defined.

It is currently assumed that the incomplete section indicates an incomplete 
image created using remote imaging. The incomplete section contains data but 
currently there is no indication what purpose the data has.

== EWF-X
EWF-X (extended) is an experimental format to enhance the EWF format. EWF-X is 
based on the EWF-E01 format. EWF-X does not limit the table entries to 16375. 
EWF-X is not the same as version 2 of EWF.

[yellow-background]*TODO add note about the table entry limit.*

=== Sections
Additional sections provided in the EWF-X format are:

* xheader
* xhash

==== Xheader
The xheader section contains a zlib compressed data (see section:
3 Compression) containing XML data containing the header values.
....
<?xml version="1.0" encoding="UTF-8"?>
<xheader>
        <case_number>1</case_number>
        <description>Description</description>
        <examiner_name>John D.</examiner_name>
        <evidence_number>1.1</evidence_number>
        <notes>Just a floppy in my system</notes>
        <acquiry_operating_system>Linux</acquiry_operating_system>
        <acquiry_date>Sat Jan 20 18:32:08 2007 CET</acquiry_date>
        <acquiry_software>ewfacquire</acquiry_software>
        <acquiry_software_version>20070120</acquiry_software_version>
</xheader>
....

==== Xhash
The xhash section contains a zlib compressed data (see section: 
<<compression,Compression>>) containing XML data containing the hash values.
....
<?xml version="1.0" encoding="UTF-8"?>
<xhash>
        <MD5>ae1ce8f5ac079d3ee93f97fe3792bda3</MD5>
        <SHA1>31a58f090460b92220d724b28eeb2838a1df6184</SHA1>
</xhash>
....

=== GUID
EWF-X uses a random based version of the GUID

== [[compression]]Compression
=== Zlib compressed data
The compressed data is stored in the the zlib compressed data format (RFC1950). 
This format uses big-endian.

The compressed data is variable of size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0.0 | 4 bits | | Compression method
| 0.4 | 4 bits | | Compression information
| 1.0 | 5 bits | | Check bits
| 1.5 | 1 bit | | Preset dictionary flag
| 1.6 | 2 bits | | Compression level
4+| _If the preset dictionary flag is set_
| 2 | 4 | | Preset dictionary identifier +
Adler-32 used to identifier the preset dictionary
4+| _Common_
| ... | ... | | Compressed chunk data
| ... | 4 | | Checksum +
Adler-32 of the chunk data
|===

The check bits value must be such that when the first 2 bytes are represented 
as a 16-bit unsigned integer in big-endian byte order the value is a multiple 
of 31.

==== Compression method

[cols="1,1,5",options="header"]
|===
| Value | Identifier | Description
| 8 | | Deflate (RFC1951)
| | | 
| 15 | | Reserved
|===

`[RFC1950]` only defines 8 as a valid compression method.

==== Compression information - compression method 8 (Deflate)
For compression method 8 (Deflate) the compression information contains the 
base-2 logarithm of the LZ77 window size minus 8.

To determine the corresponding window size:
....
1 << ( 7 + 8 )
....

E.g. A compression information value of 7 indicates a 32768 bytes window size. 
Values larger than 7 are not allowed according to `[RFC1950]` and thus the 
maximum windows size is 32768 bytes.

==== Compression level

[cols="1,1,5",options="header"]
|===
| Value | Identifier | Description
| 0 | | Fastest
| 1 | | Fast
| 2 | | Default
| 3 | | Slowest, maximum compression
|===

=== Deflate compression
The deflate compressed data consists of one or more deflate compressed blocks. 
Each block consists of:

* block header
* block data

==== Deflate compressed block header
The deflate compressed block header is 3 bits in size and consists of:

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0 | 1 bit | | Last block (in stream) marker: +
0 => not last block +
1 => last block
| 0.1 | 2 bits | | Block type
|===

==== Deflate compressed block types

[cols="1,1,5",options="header"]
|===
| Value | Identifier | Description
| 0 | | uncompressed data
| 1 | | static Huffman compressed data
| 2 | | dynamic Huffman compressed data
| 3 | | reserved (not used)
|===

==== Uncompressed block data

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0.3 | 5 bits | | Empty values (not used)
| 1 | 2 | | Uncompressed data size
| 3 | 2 | | Copy of uncompressed data size +
Contains a 1s complement of the uncompressed data size
| 5 | ... | | Uncompressed data
|===

The uncompressed data size can range between 0 and 65535 bytes.

==== Huffman compressed block data
[yellow-background]*TODO add description*

Compressed data blocks consists of 3 types of symbols:

* literal byte values
* end-of-block marker
* (size, offset) tuples

These symbols are merged in a single "alphabet" where:

[cols="1,1,5",options="header"]
|===
| Value | Identifier | Description
| 0x00 - 0xff | | literal byte values
| 0x100 | | end-of-block marker
3+| _0 additional bits_
| 0x101 | | Size of 3
| 0x102 | | Size of 4
| 0x103 | | Size of 5
| 0x104 | | Size of 6
| 0x105 | | Size of 7
| 0x106 | | Size of 8
| 0x107 | | Size of 9
| 0x108 | | Size of 10
3+| _1 additional bit_
| 0x109 | | Size of [11, 12]
| 0x10a | | Size of [13, 14]
| 0x10b | | Size of [15, 16]
| 0x10c | | Size of [17, 18]
3+| _2 additional bits_
| 0x10d | | Size of [19, 22]
| 0x10e | | Size of [23, 26]
| 0x10f | | Size of [27, 30]
| 0x110 | | Size of [31, 34]
3+| _3 additional bits_
| 0x111 | | Size of [35, 42]
| 0x112 | | Size of [43, 50]
| 0x113 | | Size of [51, 58]
| 0x114 | | Size of [59, 66]
3+| _4 additional bits_
| 0x115 | | Size of [67, 82]
| 0x116 | | Size of [83, 98]
| 0x117 | | Size of [99, 114]
| 0x118 | | Size of [115, 130]
3+| _5 additional bits_
| 0x119 | | Size of [131, 162]
| 0x11a | | Size of [163, 194]
| 0x11b | | Size of [195, 226]
| 0x11c | | Size of [227, 257]
3+| _0 additional bits_
| 0x11d | | Size of 258
|===

The additional bits are stored in big-endian (MSB first) and indicate the index 
into the corresponding array of size values (or base size + additional size).

[cols="1,1,5",options="header"]
|===
| Value | Identifier | Description
3+| _0 additional bits_
| 0 | | Offset of 1
| 1 | | Offset of 2
| 2 | | Offset of 3
| 3 | | Offset of 4
3+| _1 additional bit_
| | |
|===

[yellow-background]*TODO merge with table*
....
             Extra           Extra               Extra
             Code Bits Dist  Code Bits   Dist     Code Bits Distance
             ---- ---- ----  ---- ----  ------    ---- ---- --------
               4   1   5,6    14   6    129-192   24   11   4097-6144
               5   1   7,8    15   6    193-256   25   11   6145-8192
               6   2   9-12   16   7    257-384   26   12  8193-12288
               7   2  13-16   17   7    385-512   27   12 12289-16384
               8   3  17-24   18   8    513-768   28   13 16385-24576
               9   3  25-32   19   8   769-1024   29   13 24577-32768
10   4     33-48    20    9   1025-1536
11   4     49-64    21    9   1537-2048
12   5     65-96    22   10   2049-3072
13   5     97-128   23   10   3073-4096
....

==== Dynamic Huffman compressed block data

[cols="1,1,1,5",options="header"]
|===
| Offset | Size | Value | Description
| 0.3 | | | Code size
| | | | Distance code
|===

[yellow-background]*TODO merge with table*
....
               5 Bits: HLIT, # of Literal/Length codes - 257 (257 - 286)
               5 Bits: HDIST, # of Distance codes - 1        (1 - 32)
               4 Bits: HCLEN, # of Code Length codes - 4     (4 - 19)
 (HCLEN + 4) x 3 bits: code lengths for the code length
                  alphabet given just above, in the order: 16, 17, 18,
                  0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15

                  These code lengths are interpreted as 3-bit integers
                  (0-7); as above, a code length of 0 means the
                  corresponding symbol (literal/length or distance code
                  length) is not used.

               HLIT + 257 code lengths for the literal/length alphabet,
                  encoded using the code length Huffman code

               HDIST + 1 code lengths for the distance alphabet,
                  encoded using the code length Huffman code

               The actual compressed data of the block,
                  encoded using the literal/length and distance Huffman
                  codes

               The literal/length symbol 256 (end of data),
                  encoded using the literal/length Huffman code

         The code length repeat codes can cross from HLIT + 257 to the
         HDIST + 1 code lengths.  In other words, all code lengths form
         a single sequence of HLIT + HDIST + 258 values.
....

The code size is encoded in the following Huffman encoding:

[cols="1,1,5",options="header"]
|===
| Value | Identifier | Description
| 0 - 15 | | Represent code size of 0 - 15
| 16 | | Copy the previous code size 3 - 6 times. +
The next 2 bits indicate repeat length (0 = 3, ... , 3 = 6) +
Example: Codes 8, 16 (+2 bits 11), 16 (+2 bits 10) will expand to 12 code lengths of 8 (1 + 6 + 5)
| 17 | | Repeat a code length of 0 for 3 - 10 times. (3 bits of length)
| 18 | | Repeat a code length of 0 for 11 - 138 times (7 bits of length)
|===

A code size of 0 indicates that the corresponding symbol in the literal/length 
or distance alphabet will not occur in the block, and should not participate in 
the Huffman code.

==== Decompression
[yellow-background]*TODO add description*
....
do
{
    read block_header from input stream

    if( block_header.type == UNCOMPRESSED )
    {
        align with next byte
        read block_header.size and block_header.size_copy
        read data of block_header.size
    }
    else
    {
        if( block_header.type == HUFFMANN_DYNAMIC )
        {
            read representation of code trees (see subsection below)
        }
        loop (until end of block code recognized)
        {
            decode literal/length value from input stream
            if( value < 256 )
            {
                copy value (literal byte) to output stream
            }
            else
            {
                if value = end of block (256)
                {
                    break from loop
                }
                else (value = 257..285)
                {
                    decode distance from input stream

                    move backwards distance bytes in the output
                    stream, and copy length bytes from this
                    position to the output stream.
                }
            }
        }
    }
}
while( block_header.last_block_flag == 0 );
....

=== Adler-32 checksum
The checksum algorithm provided by `[ASR02]`, slightly altered for readability. 
The algorithm used is Alder-32 and `[ASR02]` incorrectly refers to it as a CRC.

....
uint32_t Expert_Witness_Compression_CRC(
          uint8_t *buffer,
          size_t buffer_size,
          uint32_t previous_key )
{
	size_t buffer_iterator = 0;
	uint32_t lower_word    = previous_key & 0xffff;
	uint32_t upper_word    = ( previous_key >> 16 ) & 0xffff;

	for( buffer_iterator = 0;
	     buffer_iterator < buffer_size;
	     buffer_iterator++ )
	{
		lower_word += buffer[ buffer_iterator ];
		upper_word += lower_word;

		if( ( buffer_iterator != 0 )
		 && ( ( buffer_iterator % 0x15b0 == 0 )
		  || ( buffer_iterator == buffer_size - 1 ) ) )
		{
			lower_word = lower_word % 0xfff1;
			upper_word = upper_word % 0xfff1;
		}
	}
	return( ( upper_word << 16 ) | lower_word );
}
....

Zlib provides the function adler32 which is an optimized version of the 
algorithm.

== Corruption scenarios
This chapter contains several corruption scenarios that have been encountered 
"in the wild".

=== Corrupt uncompressed chunk
[yellow-background]*TODO add description*

=== Corrupt compressed chunk
[yellow-background]*TODO add description*

=== Corrupt section descriptor
[yellow-background]*TODO add description*

....
libewf_section_start_read: reading section start from file IO pool entry: 1 at offset: 415912423
libewf_section_start_read: type                      : table2
libewf_section_start_read: next offset               : 415978027
libewf_section_start_read: size                      : 65604
libewf_section_start_read: checksum                  : 0xf35f03e0
libewf_section_table_header_read: number of offsets  : 16375
libewf_section_table_header_read: base offset        : 0x00000000
libewf_section_table_header_read: checksum           : 0x180d0137

libewf_section_start_read: reading section start from file IO pool entry: 1 at offset: 415978027
libewf_section_start_read: type                      : sectors
libewf_section_start_read: next offset               : 415978027
libewf_section_start_read: size                      : 0
libewf_section_start_read: checksum                  : 0x1ad00464
....

=== Corrupt table section
[yellow-background]*TODO add description*

[yellow-background]*with and with out table 2*

[yellow-background]*number of entries*

[yellow-background]*entry data*

=== Corrupted segment file header
[yellow-background]*TODO add description*

=== Partial segment file
[yellow-background]*TODO add description*

=== Missing segment file(s)
[yellow-background]*TODO add description*

=== Dual image: section size versus offset
The sections descriptors define both the next section offset and the size of 
the section. If an implementation reads only one of the two to determine the 
next section, a dual EWF image can be crafted that consists of two separate 
images including hashes.

A current version of libewf will mark such an image as corrupted, but older 
versions only checked the section size and will show one of the two valid 
images.

=== Table entries offset overflow
In EnCase 6.7.1 the sectors section can be larger than 2048 MiB. The table 
entries offsets are 31 bit values in EnCase6 the offset in a table entry value 
will actually use the full 32 bit if the 2048 MiB has been exceeded. This 
behavior is no longer present in EnCase 6.8 so it is assumed to be a bug.

Libewf currently assumes that the if the 31 bit value overflows the following 
chunks are uncompressed. This allows EnCase 6.7.1 faulty EWF files to be 
converted by libewf.

=== Multiple incomplete segment file set identifiers
Although rare it can occur that a set of EWF image files changes its segment 
file set identifier. This was seen in an image created by EnCase 6.13, 
presumably using remote imaging. The image contained 3 different segment file 
set identifiers. The first changes after an incomplete section. The second one 
changed without any clear indication. The corresponding data section also 
changed in some extent e.g. compression method and media flags, the is physical 
flag being dropped. The change was consistent across multiple segment files. It 
is unlikely that deliberate manipulation is involved. EnCase considers the 
image as invalid.

Although with some tweaking of libewf the individual segment file sets could be 
read. In this case the data read from the segment file sets was heavily 
corrupted. For now a stock libewf does not support reading multiple segment 
files sets from a single image, but this might change in the future.

=== Notes
[yellow-background]*TODO add description*
[yellow-background]*metadata (volume, data, headers)*

== AD encryption
As of version 2.8 FTK Imager supports "AD encryption". Although the output file 
uses the EWF extensions the file actually is a AES-256 encrypted container. The 
EWF can be encrypted using a pass-phrase or a certificate.

== Notes
What about:

* PALM volume
* the SMART logs

=== AD encryption
The AccessData encryption format is a single-file encryption method often used to
encrypt AccessData and EnCase forensic images.  The input file (which can be
anything) is encrypted with AES using a user-supplied password or public key
and a header is prepended onto the resulting ciphertext to allow for decryption
with the same password or corresponding private key.

The container consists of a header followed by the encrypted data.  The header is
padded out to the nearest 512-byte boundary (typically it is just 512 bytes); all
header values are in little-endian order.  AccessData has provided a https://support.accessdata.com/hc/en-us/article_attachments/201953867/AD1___Image_Encryption_Technical_White_Paper.pdf[whitepaper]
with some generally useful format information.

==== Header
The header format is:

[cols="1,1,5",options="header"]
|===
| Offset | Size | Description
| 0 | 8 | File signature: 
"ADCRYPT\x00"
| 8 | 4 | Version - 0x01000000
| 12 | 4 | Header length (= offset of first encrypted data byte)
| 16 | 2 | Number of passwords (or -1 if unknown/unset)
| 18 | 2 | Number of raw keys (or -1 if unknown/unset)
| 20 | 2 | Number of certificates (or -1 if unknown/unset)
| 22 | 2 | Reserved (must be 0x0000)
| 24 | 4 | Encryption algorithm: 1=AES-128, 2=AES-192, 3=AES-256
| 28 | 4 | Hash algorithm: 1=SHA-256, 2=SHA-512
| 32 | 4 | PBKDF2 iteration count (**I**)
| 36 | 4 | Salt length (**S**)
| 40 | 4 | Key length (**K**)
| 44 | 4 | HMAC length (**H**)
| 48 | S | Encrypted salt (**ESALT**)
| 48 + S | K | Encrypted key (**EKEY**)
| 48 + S + K | H | HMAC of encrypted key (**HMAC**)
|===

The header is then padded with null bytes to the following 512-byte boundary,
after which follows the encrypted file.

Although the encryption protocol has some configurable settings, most (if not
all) files will use the defaults: AES-256 for encryption, SHA-512 for hashing,
4000 iterations of PBKDF2.

==== Protocol

All AES encryption steps use AES in CTR mode with an IV of all null bytes and
a simple incrementing little-endian counter starting at 0.

The encryption protocol is as follows:

* Generate a random encryption key FKEY of length K
* Encrypt the target file with the specified AES version and key FKEY
* Generate a random salt SALT
* Generate a new encryption key PKEY from the user password hashed with the
  specified hash algorithm (or the empty string, if there is no user password):
  `PKEY = PBKDF2(hash(user_pw) || '', SALT, I, K)`
* Encrypt FKEY using the specified AES version and key PKEY to generate EKEY
* If the user supplied a public key, use it to encrypt SALT and generate ESALT,
  otherwise ESALT = SALT
* Compute an HMAC of the encrypted key EKEY with PKEY using the specified hash
  algorithm

The decryption procedure is thus:

* If using a private key, decrypt the encrypted salt ESALT to get the original
  SALT (if no key, SALT = ESALT)
* Regenerate the encryption key PKEY from the user password hashed with the
  specified hash algorithm (or the empty string, if there is no user password):
  `PKEY = PBKDF2(hash(user_pw) || '', SALT, I, K)`
* Optionally verify the HMAC of EKEY using PKEY and the specified hash algorithm,
  comparing it with the header HMAC
* Decrypt the encrypted key using AES with PKEY to get FKEY
* Decrypt the file ciphertext using AES with FKEY

=== Header
[yellow-background]*All test headers consist of the where spaces are actually 
tabs separated values*

....
srce
0       1
p       n       id      ev      tb      lo      po      ah      gu      aq
0       0
                                        -1      -1

sub
0       1
p       n       id      nu      co      gu
0       0
                                1
....

=== Ltree
When p = 0 n contains a numeric value ([yellow-background]*the number of child entries of the following entry*)
When p = 1 n contains the name of the directory.
When p = is empty n contains the name of the file.

:numbered!:
[appendix]
== References

`[ASR02]`

[cols="1,5",options="header"]
|===
| Title: | ASR Expert Witness Compression Format specification
| Author(s) | Andrew Rosen
| URL: | http://www.asrdata.com/SMART/whitepaper.html
|===

`[COH]`

[cols="1,5",options="header"]
|===
| Title: | PyFlag libevf source code
| Author(s) | Michael Cohen
| URL: | http://www.pyflag.net/
|===

`[FWIKI]`

[cols="1,5",options="header"]
|===
| Title: | Forensic Wiki
| URL: | http://www.forensicswiki.org/index.php/Forensic_file_formats +
http://www.forensicswiki.org/index.php/EnCase
|===

`[RFC1950]`

[cols="1,5",options="header"]
|===
| Title: | ZLIB Compressed Data Format Specification
| Version: | 3.3
| Author(s): | P. Deutsch, J-L. Gailly
| Date: | May 1996
| URL: | http://www.ietf.org/rfc/rfc1950.txt
|===

`[RFC1951]`

[cols="1,5",options="header"]
|===
| Title: | DEFLATE Compressed Data Format Specification
| Version: | 1.3
| Author(s): | P. Deutsch
| Date: | May 1996
| URL: | http://www.ietf.org/rfc/rfc1951.txt
|===

`[RFC4122]`

[cols="1,5",options="header"]
|===
| Title: | A Universally Unique Identifier (UUID) URN Namespace
| Author(s): | P. Leach, M. Mealling, R. Salz
| Date: | July 2005
| URL: | http://www.ietf.org/rfc/rfc4122.txt
|===

[appendix]
== GNU Free Documentation License
Version 1.3, 3 November 2008
Copyright © 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc. 
<http://fsf.org/>

Everyone is permitted to copy and distribute verbatim copies of this license 
document, but changing it is not allowed.

=== 0. PREAMBLE
The purpose of this License is to make a manual, textbook, or other functional 
and useful document "free" in the sense of freedom: to assure everyone the 
effective freedom to copy and redistribute it, with or without modifying it, 
either commercially or noncommercially. Secondarily, this License preserves for 
the author and publisher a way to get credit for their work, while not being 
considered responsible for modifications made by others.

This License is a kind of "copyleft", which means that derivative works of the 
document must themselves be free in the same sense. It complements the GNU 
General Public License, which is a copyleft license designed for free software.

We have designed this License in order to use it for manuals for free software, 
because free software needs free documentation: a free program should come with 
manuals providing the same freedoms that the software does. But this License is 
not limited to software manuals; it can be used for any textual work, 
regardless of subject matter or whether it is published as a printed book. We 
recommend this License principally for works whose purpose is instruction or 
reference.

=== 1. APPLICABILITY AND DEFINITIONS
This License applies to any manual or other work, in any medium, that contains 
a notice placed by the copyright holder saying it can be distributed under the 
terms of this License. Such a notice grants a world-wide, royalty-free license, 
unlimited in duration, to use that work under the conditions stated herein. The 
"Document", below, refers to any such manual or work. Any member of the public 
is a licensee, and is addressed as "you". You accept the license if you copy, 
modify or distribute the work in a way requiring permission under copyright law.

A "Modified Version" of the Document means any work containing the Document or 
a portion of it, either copied verbatim, or with modifications and/or 
translated into another language.

A "Secondary Section" is a named appendix or a front-matter section of the 
Document that deals exclusively with the relationship of the publishers or 
authors of the Document to the Document's overall subject (or to related 
matters) and contains nothing that could fall directly within that overall 
subject. (Thus, if the Document is in part a textbook of mathematics, a 
Secondary Section may not explain any mathematics.) The relationship could be a 
matter of historical connection with the subject or with related matters, or of 
legal, commercial, philosophical, ethical or political position regarding them.

The "Invariant Sections" are certain Secondary Sections whose titles are 
designated, as being those of Invariant Sections, in the notice that says that 
the Document is released under this License. If a section does not fit the 
above definition of Secondary then it is not allowed to be designated as 
Invariant. The Document may contain zero Invariant Sections. If the Document 
does not identify any Invariant Sections then there are none.

The "Cover Texts" are certain short passages of text that are listed, as 
Front-Cover Texts or Back-Cover Texts, in the notice that says that the 
Document is released under this License. A Front-Cover Text may be at most 5 
words, and a Back-Cover Text may be at most 25 words.

A "Transparent" copy of the Document means a machine-readable copy, represented 
in a format whose specification is available to the general public, that is 
suitable for revising the document straightforwardly with generic text editors 
or (for images composed of pixels) generic paint programs or (for drawings) 
some widely available drawing editor, and that is suitable for input to text 
formatters or for automatic translation to a variety of formats suitable for 
input to text formatters. A copy made in an otherwise Transparent file format 
whose markup, or absence of markup, has been arranged to thwart or discourage 
subsequent modification by readers is not Transparent. An image format is not 
Transparent if used for any substantial amount of text. A copy that is not 
"Transparent" is called "Opaque".

Examples of suitable formats for Transparent copies include plain ASCII without 
markup, Texinfo input format, LaTeX input format, SGML or XML using a publicly 
available DTD, and standard-conforming simple HTML, PostScript or PDF designed 
for human modification. Examples of transparent image formats include PNG, XCF 
and JPG. Opaque formats include proprietary formats that can be read and edited 
only by proprietary word processors, SGML or XML for which the DTD and/or 
processing tools are not generally available, and the machine-generated HTML, 
PostScript or PDF produced by some word processors for output purposes only.

The "Title Page" means, for a printed book, the title page itself, plus such 
following pages as are needed to hold, legibly, the material this License 
requires to appear in the title page. For works in formats which do not have 
any title page as such, "Title Page" means the text near the most prominent 
appearance of the work's title, preceding the beginning of the body of the text.

The "publisher" means any person or entity that distributes copies of the 
Document to the public.

A section "Entitled XYZ" means a named subunit of the Document whose title 
either is precisely XYZ or contains XYZ in parentheses following text that 
translates XYZ in another language. (Here XYZ stands for a specific section 
name mentioned below, such as "Acknowledgements", "Dedications", 
"Endorsements", or "History".) To "Preserve the Title" of such a section when 
you modify the Document means that it remains a section "Entitled XYZ" 
according to this definition.

The Document may include Warranty Disclaimers next to the notice which states 
that this License applies to the Document. These Warranty Disclaimers are 
considered to be included by reference in this License, but only as regards 
disclaiming warranties: any other implication that these Warranty Disclaimers 
may have is void and has no effect on the meaning of this License.

=== 2. VERBATIM COPYING
You may copy and distribute the Document in any medium, either commercially or 
noncommercially, provided that this License, the copyright notices, and the 
license notice saying this License applies to the Document are reproduced in 
all copies, and that you add no other conditions whatsoever to those of this 
License. You may not use technical measures to obstruct or control the reading 
or further copying of the copies you make or distribute. However, you may 
accept compensation in exchange for copies. If you distribute a large enough 
number of copies you must also follow the conditions in section 3.

You may also lend copies, under the same conditions stated above, and you may 
publicly display copies.

=== 3. COPYING IN QUANTITY
If you publish printed copies (or copies in media that commonly have printed 
covers) of the Document, numbering more than 100, and the Document's license 
notice requires Cover Texts, you must enclose the copies in covers that carry, 
clearly and legibly, all these Cover Texts: Front-Cover Texts on the front 
cover, and Back-Cover Texts on the back cover. Both covers must also clearly 
and legibly identify you as the publisher of these copies. The front cover must 
present the full title with all words of the title equally prominent and 
visible. You may add other material on the covers in addition. Copying with 
changes limited to the covers, as long as they preserve the title of the 
Document and satisfy these conditions, can be treated as verbatim copying in 
other respects.

If the required texts for either cover are too voluminous to fit legibly, you 
should put the first ones listed (as many as fit reasonably) on the actual 
cover, and continue the rest onto adjacent pages.

If you publish or distribute Opaque copies of the Document numbering more than 
100, you must either include a machine-readable Transparent copy along with 
each Opaque copy, or state in or with each Opaque copy a computer-network 
location from which the general network-using public has access to download 
using public-standard network protocols a complete Transparent copy of the 
Document, free of added material. If you use the latter option, you must take 
reasonably prudent steps, when you begin distribution of Opaque copies in 
quantity, to ensure that this Transparent copy will remain thus accessible at 
the stated location until at least one year after the last time you distribute 
an Opaque copy (directly or through your agents or retailers) of that edition 
to the public.

It is requested, but not required, that you contact the authors of the Document 
well before redistributing any large number of copies, to give them a chance to 
provide you with an updated version of the Document.

=== 4. MODIFICATIONS
You may copy and distribute a Modified Version of the Document under the 
conditions of sections 2 and 3 above, provided that you release the Modified 
Version under precisely this License, with the Modified Version filling the 
role of the Document, thus licensing distribution and modification of the 
Modified Version to whoever possesses a copy of it. In addition, you must do 
these things in the Modified Version:

A. Use in the Title Page (and on the covers, if any) a title distinct from that 
of the Document, and from those of previous versions (which should, if there 
were any, be listed in the History section of the Document). You may use the 
same title as a previous version if the original publisher of that version 
gives permission. 

B. List on the Title Page, as authors, one or more persons or entities 
responsible for authorship of the modifications in the Modified Version, 
together with at least five of the principal authors of the Document (all of 
its principal authors, if it has fewer than five), unless they release you from 
this requirement. 

C. State on the Title page the name of the publisher of the Modified Version, 
as the publisher. 

D. Preserve all the copyright notices of the Document. 

E. Add an appropriate copyright notice for your modifications adjacent to the 
other copyright notices. 

F. Include, immediately after the copyright notices, a license notice giving 
the public permission to use the Modified Version under the terms of this 
License, in the form shown in the Addendum below. 

G. Preserve in that license notice the full lists of Invariant Sections and 
required Cover Texts given in the Document's license notice. 

H. Include an unaltered copy of this License. 

I. Preserve the section Entitled "History", Preserve its Title, and add to it 
an item stating at least the title, year, new authors, and publisher of the 
Modified Version as given on the Title Page. If there is no section Entitled 
"History" in the Document, create one stating the title, year, authors, and 
publisher of the Document as given on its Title Page, then add an item 
describing the Modified Version as stated in the previous sentence. 

J. Preserve the network location, if any, given in the Document for public 
access to a Transparent copy of the Document, and likewise the network 
locations given in the Document for previous versions it was based on. These 
may be placed in the "History" section. You may omit a network location for a 
work that was published at least four years before the Document itself, or if 
the original publisher of the version it refers to gives permission. 

K. For any section Entitled "Acknowledgements" or "Dedications", Preserve the 
Title of the section, and preserve in the section all the substance and tone of 
each of the contributor acknowledgements and/or dedications given therein. 

L. Preserve all the Invariant Sections of the Document, unaltered in their text 
and in their titles. Section numbers or the equivalent are not considered part 
of the section titles. 

M. Delete any section Entitled "Endorsements". Such a section may not be 
included in the Modified Version. 

N. Do not retitle any existing section to be Entitled "Endorsements" or to 
conflict in title with any Invariant Section. 

O. Preserve any Warranty Disclaimers. 

If the Modified Version includes new front-matter sections or appendices that 
qualify as Secondary Sections and contain no material copied from the Document, 
you may at your option designate some or all of these sections as invariant. To 
do this, add their titles to the list of Invariant Sections in the Modified 
Version's license notice. These titles must be distinct from any other section 
titles.

You may add a section Entitled "Endorsements", provided it contains nothing but 
endorsements of your Modified Version by various parties—for example, 
statements of peer review or that the text has been approved by an organization 
as the authoritative definition of a standard.

You may add a passage of up to five words as a Front-Cover Text, and a passage 
of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts 
in the Modified Version. Only one passage of Front-Cover Text and one of 
Back-Cover Text may be added by (or through arrangements made by) any one 
entity. If the Document already includes a cover text for the same cover, 
previously added by you or by arrangement made by the same entity you are 
acting on behalf of, you may not add another; but you may replace the old one, 
on explicit permission from the previous publisher that added the old one.

The author(s) and publisher(s) of the Document do not by this License give 
permission to use their names for publicity for or to assert or imply 
endorsement of any Modified Version.

=== 5. COMBINING DOCUMENTS
You may combine the Document with other documents released under this License, 
under the terms defined in section 4 above for modified versions, provided that 
you include in the combination all of the Invariant Sections of all of the 
original documents, unmodified, and list them all as Invariant Sections of your 
combined work in its license notice, and that you preserve all their Warranty 
Disclaimers.

The combined work need only contain one copy of this License, and multiple 
identical Invariant Sections may be replaced with a single copy. If there are 
multiple Invariant Sections with the same name but different contents, make the 
title of each such section unique by adding at the end of it, in parentheses, 
the name of the original author or publisher of that section if known, or else 
a unique number. Make the same adjustment to the section titles in the list of 
Invariant Sections in the license notice of the combined work.

In the combination, you must combine any sections Entitled "History" in the 
various original documents, forming one section Entitled "History"; likewise 
combine any sections Entitled "Acknowledgements", and any sections Entitled 
"Dedications". You must delete all sections Entitled "Endorsements".

=== 6. COLLECTIONS OF DOCUMENTS
You may make a collection consisting of the Document and other documents 
released under this License, and replace the individual copies of this License 
in the various documents with a single copy that is included in the collection, 
provided that you follow the rules of this License for verbatim copying of each 
of the documents in all other respects.

You may extract a single document from such a collection, and distribute it 
individually under this License, provided you insert a copy of this License 
into the extracted document, and follow this License in all other respects 
regarding verbatim copying of that document.

=== 7. AGGREGATION WITH INDEPENDENT WORKS
A compilation of the Document or its derivatives with other separate and 
independent documents or works, in or on a volume of a storage or distribution 
medium, is called an "aggregate" if the copyright resulting from the 
compilation is not used to limit the legal rights of the compilation's users 
beyond what the individual works permit. When the Document is included in an 
aggregate, this License does not apply to the other works in the aggregate 
which are not themselves derivative works of the Document.

If the Cover Text requirement of section 3 is applicable to these copies of the 
Document, then if the Document is less than one half of the entire aggregate, 
the Document's Cover Texts may be placed on covers that bracket the Document 
within the aggregate, or the electronic equivalent of covers if the Document is 
in electronic form. Otherwise they must appear on printed covers that bracket 
the whole aggregate.

=== 8. TRANSLATION
Translation is considered a kind of modification, so you may distribute 
translations of the Document under the terms of section 4. Replacing Invariant 
Sections with translations requires special permission from their copyright 
holders, but you may include translations of some or all Invariant Sections in 
addition to the original versions of these Invariant Sections. You may include 
a translation of this License, and all the license notices in the Document, and 
any Warranty Disclaimers, provided that you also include the original English 
version of this License and the original versions of those notices and 
disclaimers. In case of a disagreement between the translation and the original 
version of this License or a notice or disclaimer, the original version will 
prevail.

If a section in the Document is Entitled "Acknowledgements", "Dedications", or 
"History", the requirement (section 4) to Preserve its Title (section 1) will 
typically require changing the actual title.

=== 9. TERMINATION
You may not copy, modify, sublicense, or distribute the Document except as 
expressly provided under this License. Any attempt otherwise to copy, modify, 
sublicense, or distribute it is void, and will automatically terminate your 
rights under this License.

However, if you cease all violation of this License, then your license from a 
particular copyright holder is reinstated (a) provisionally, unless and until 
the copyright holder explicitly and finally terminates your license, and (b) 
permanently, if the copyright holder fails to notify you of the violation by 
some reasonable means prior to 60 days after the cessation.

Moreover, your license from a particular copyright holder is reinstated 
permanently if the copyright holder notifies you of the violation by some 
reasonable means, this is the first time you have received notice of violation 
of this License (for any work) from that copyright holder, and you cure the 
violation prior to 30 days after your receipt of the notice.

Termination of your rights under this section does not terminate the licenses 
of parties who have received copies or rights from you under this License. If 
your rights have been terminated and not permanently reinstated, receipt of a 
copy of some or all of the same material does not give you any rights to use it.

=== 10. FUTURE REVISIONS OF THIS LICENSE
The Free Software Foundation may publish new, revised versions of the GNU Free 
Documentation License from time to time. Such new versions will be similar in 
spirit to the present version, but may differ in detail to address new problems 
or concerns. See http://www.gnu.org/copyleft/.

Each version of the License is given a distinguishing version number. If the 
Document specifies that a particular numbered version of this License "or any 
later version" applies to it, you have the option of following the terms and 
conditions either of that specified version or of any later version that has 
been published (not as a draft) by the Free Software Foundation. If the 
Document does not specify a version number of this License, you may choose any 
version ever published (not as a draft) by the Free Software Foundation. If the 
Document specifies that a proxy can decide which future versions of this 
License can be used, that proxy's public statement of acceptance of a version 
permanently authorizes you to choose that version for the Document.

=== 11. RELICENSING
"Massive Multiauthor Collaboration Site" (or "MMC Site") means any World Wide 
Web server that publishes copyrightable works and also provides prominent 
facilities for anybody to edit those works. A public wiki that anybody can edit 
is an example of such a server. A "Massive Multiauthor Collaboration" (or 
"MMC") contained in the site means any set of copyrightable works thus 
published on the MMC site.

"CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0 license 
published by Creative Commons Corporation, a not-for-profit corporation with a 
principal place of business in San Francisco, California, as well as future 
copyleft versions of that license published by that same organization.

"Incorporate" means to publish or republish a Document, in whole or in part, as 
part of another Document.

An MMC is "eligible for relicensing" if it is licensed under this License, and 
if all works that were first published under this License somewhere other than 
this MMC, and subsequently incorporated in whole or in part into the MMC, (1) 
had no cover texts or invariant sections, and (2) were thus incorporated prior 
to November 1, 2008.

The operator of an MMC Site may republish an MMC contained in the site under 
CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC 
is eligible for relicensing.

